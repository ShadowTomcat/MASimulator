/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package simulator;

import model.ArthurInfo;
import model.ArthurSkill;
import model.EnemyInfo;
import model.Enums.EnumType;
import model.HandCardInfo;
import java.awt.Color;
import java.awt.Font;
import java.awt.event.MouseEvent;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import javax.swing.BorderFactory;
import javax.swing.ButtonGroup;
import javax.swing.GroupLayout;
import javax.swing.JButton;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JProgressBar;
import javax.swing.JToggleButton;
import javax.swing.SwingConstants;
import javax.swing.border.TitledBorder;
import model.BuffInfo;
import model.Constants;
import static model.Constants.CATEGORY_MAP;
import static model.Constants.SLEEP_SHORT;
import model.EnemySkill;
import model.Enums.EnumArthur;
import model.Enums.EnumAttribute;
import model.Enums.EnumBuff;
import model.Enums.EnumCardLevel;
import model.Enums.EnumPhysicsMagic;
import model.PartInfo;
import static model.Constants.*;
import model.TurnInfoRecord;
import swing.CardPanelMouseAdapter;
import swing.CardSelectionPopupMenu;
import swing.GradientPanel;
import util.UIUtil;

/**
 *
 * @author Shadow
 */
public class BattleSimu extends javax.swing.JPanel {

    /**
     * Creates new form BattleSimu
     */
    public BattleSimu() {
        initComponents();
        initComponentsByCode();
        initData();
    }

    BattleSimu(String enemyPartyId, List<ArthurInfo> arthurList, List<EnemyInfo> enemyList,
            HashMap<String, List<String[]>> skillMap, HashMap<String, List<String[]>> skillRoleMap,
            HashMap<String, String[]> enemyAiOrderMap) {
        this.enemyPartyId = enemyPartyId;
        this.arthurList = arthurList;
        this.enemyList = enemyList;
        this.skillMap = skillMap;
        this.skillRoleMap = skillRoleMap;
        this.enemyAiOrderMap = enemyAiOrderMap;
        initComponents();
        initComponentsByCode();
        initData();
        initListener();
        prepareBattle();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 877, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 599, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents


    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
    private static final org.apache.log4j.Logger log = org.apache.log4j.Logger.getLogger(BattleSimu.class);
    public final Font defaultFont = new java.awt.Font("宋体", 0, 12);
    private HashMap<String, List<String[]>> skillMap;
    private HashMap<String, List<String[]>> skillRoleMap;
    private HashMap<String, String[]> enemyAiOrderMap;
    //private HashMap<String, Integer[]> classAttrMap;
    private String[] enemyName;
    private String[] arthurName;

    private List<EnemyInfo> enemyList;
    private List<ArthurInfo> arthurList;
    private String enemyPartyId;
    private Integer turn;
    private boolean showCards;  // Show cards or sphere

    // During playing a skill.
    private Integer playedIndex;
    private Integer[][] playedTargets;      // Used when user try to select a target.
    private Boolean[][] currentChains;      // Integer[4][5] [Merc, Mill, Thie, Sing][Fire, Ice, Wind, Light, Dark]
    private Integer deckComboCount;
    private HashMap<String, Integer> enemyTriggerAiFlag;
    private Integer[] dealCardQty;          // Record deal qty.

    // For turn rollback.
    private List<TurnInfoRecord> turnInfoRecord;
    private final CardSelectionPopupMenu popupMenu = new CardSelectionPopupMenu();

    ;

    private void initData() {
    }

    public void setEnemyPartyId(String enemyPartyId) {
        this.enemyPartyId = enemyPartyId;
    }

    public void setArthurList(List<ArthurInfo> arthurList) {
        this.arthurList = arthurList;
    }

    public void setEnemyList(List<EnemyInfo> enemyList) {
        this.enemyList = enemyList;
    }

    public void prepareBattle() {
        turn = 0;
        showCards = true;
        playedTargets = null;
        currentChains = new Boolean[][]{{false, false, false, false, false}, {false, false, false, false, false},
        {false, false, false, false, false}, {false, false, false, false, false}};
        enemyTriggerAiFlag = new HashMap<>();
        refreshTargetUI(playedTargets);
        initPartBuffList();
        txtBattleInfo.setText("");
        turnInfoRecord = new ArrayList<>();

        enemyName = new String[5];
        for (int i = 0; i < 4; i++) {
            if (i >= enemyList.size()) {
                enStatus.get(i).setVisible(false);
                continue;
            }
            enemyName[i] = enemyList.get(i).getName();
            enStatus.get(i).setVisible(true);
            ((TitledBorder) enStatus.get(i).getBorder()).setTitle(enemyList.get(i).getName());
            enStatusProBar.get(i).setMaximum(enemyList.get(i).getCurrentAttr(7));
            enStatusProBar.get(i).setMinimum(0);
        }
        enemyName[4] = "敌方全体";
        refreshEnemyUI();

        arthurName = new String[5];
        for (int i = 0; i < 4; i++) {
            arthurList.get(i).createFirstRoundDeck();
            arthurName[i] = arthurList.get(i).getName();
            //testOutputFirstRoundDeck(i);
            //((TitledBorder) enStatus.get(i).getBorder()).setTitle(enemyList.get(i).getName());
            arStatusProBar.get(i).setMaximum(arthurList.get(i).getCurrentAttr(7));
            arStatusProBar.get(i).setMinimum(0);
            arStatusTButton.get(i).setText("选择卡牌");
            arStatusTButton.get(i).setEnabled(true);
        }
        arthurName[4] = "我方全体";
        refreshArthurUI();

        new Thread(new Runnable() {
            @Override
            public void run() {
                txtBattleInfo.append("————————————————战斗开始————————————————" + "\n");
                StringBuilder sb;
                boolean hasPassive = false;
                for (int i = 0; i < enemyList.size(); i++) {
                    sb = new StringBuilder();
                    EnemyInfo enemy = enemyList.get(i);
                    if (enemy.getPassiveSkill() != null && !enemy.getPassiveSkill().isEmpty()) {
                        hasPassive = true;
                        sb.append(enemy.getName()).append(" 使用被动技能——\n");
                        EnemySkill passiveSkill = new EnemySkill(enemy.getPassiveSkill(), null, 0, null, 0, 0, 100);
                        passiveSkill.setEnemyIndex(i);
                        List<String[]> skills = skillMap.get(passiveSkill.getSkillId());
                        if (!skills.get(0)[1].isEmpty()) {
                            sb.append("【").append(skills.get(0)[1]).append("】\n");
                        }
                        txtBattleInfo.append(sb.toString());
                        executeSingleEnemySkill(passiveSkill, skills);
                    }
                }
                if (hasPassive) {
                    txtBattleInfo.append("\n");
                }

                String skillId;
                for (int i = 0; i < 4; i++) {
                    sb = new StringBuilder();
                    sb.append(EnumArthur.getNameByIndex(i)).append("抽卡：\n");
                    for (int j = 0; j < 5; j++) {
                        skillId = arthurList.get(i).drawCard(turn + 1);
                        if (skillId != null) {
                            sb.append("【").append(arthurList.get(i).getDeck().get(skillId).getCardName()).append("】、");
                        }
                    }
                    sb.deleteCharAt(sb.length() - 1).append("\n");
                    txtBattleInfo.append(sb.toString());
                }
                txtBattleInfo.append("\n");
                // Will NOT trigger actionPerformed().
                arStatusTButton.get(0).setSelected(true);
                dealCardQty = new Integer[]{0, 0, 0, 0};
                nextTurn();
            }
        }).start();
    }

    /**
     * Main function. Halt user's control, compute/output user actions,
     * compute/output enemy actions. And proceed to next turn.
     */
    private void endTurn() {
        // Check skip turn.
        for (ArthurInfo arthur : arthurList) {
            if (arthur.getCostUsed() == 0) {
                if (JOptionPane.showConfirmDialog(this, arthur.getName() + "尚未行动，要结束回合吗？", "提醒", JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE)
                        == JOptionPane.NO_OPTION) {
                    return;
                } else {
                    break;
                }
            }
        }

        // process skills;
        Thread thread = new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    haltGame(true);
                    ((MainFrame) UIUtil.getMainFrame()).enableTestFunc(false);
                    btnEndTurn.grabFocus();
                    Integer isWin = processArthurSkill();
                    if (isWin == 0) {
                        isWin = computeDotDamage(false);
                        refreshArthurUI();
                        refreshEnemyUI();
                    }
                    if (isWin == 0) {
                        isWin = processEnemySkill();
                    }
                    if (isWin == 0) {
                        isWin = computeDotDamage(true);
                        refreshArthurUI();
                        refreshEnemyUI();
                    }
                    if (isWin == 0) {
                        processBuffs();
                        nextTurn();
                    } else if (isWin == -1) {
                        txtBattleInfo.append("————————————————我方全灭……———————————————" + "\n");
                        txtBattleInfo.setCaretPosition(txtBattleInfo.getText().length());
                        turnInfoRecord.add(new TurnInfoRecord()); // Last turn = dead turn.
                    } else if (isWin == 1) {
                        txtBattleInfo.append("————————————————战斗胜利！————————————————" + "\n");
                        txtBattleInfo.setCaretPosition(txtBattleInfo.getText().length());
                        turnInfoRecord.add(new TurnInfoRecord());
                    }
                    ((MainFrame) UIUtil.getMainFrame()).enableTestFunc(true);
                } catch (Exception e) {
                    log.error(e);
                    for (StackTraceElement element : e.getStackTrace()) {
                        log.error(element);
                    }
                }
            }
        });
        thread.start();

    }

    private void nextTurn() {
        turn += 1;
        deckComboCount = 0;     // Reset combo count
        lblTitle.setText("第" + turn + "回合");
        txtBattleInfo.append("＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝第" + turn + "回合＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝\n\n");
        txtBattleInfo.setCaretPosition(txtBattleInfo.getText().length());
        if (turn > 1) {
            sleep(SLEEP_SHORT);
        }
        StringBuilder sb;

        // Refresh (clear) Damage
        for (int i = 0; i < arthurList.size(); i++) {
            arthurList.get(i).setmDamageTakenNowTurn(0);
            arthurList.get(i).setpDamageTakenNowTurn(0);
            arthurList.get(i).seteDamageTakenNowTurn(0, null);
            arthurList.get(i).setDamageTakenNowTurn(0);
            arthurList.get(i).setHealTakenNowTurn(0);
        }
        for (int i = 0; i < enemyList.size(); i++) {
            enemyList.get(i).setmDamageTakenNowTurn(0);
            enemyList.get(i).setpDamageTakenNowTurn(0);
            enemyList.get(i).seteDamageTakenNowTurn(0, null);
            enemyList.get(i).setDamageNumNowTurn(0, 3);
            enemyList.get(i).setDamageTakenNowTurn(0);
            enemyList.get(i).setHealTakenNowTurn(0);
        }

        // Regenerate
        sb = new StringBuilder();
        Integer hpIndex = EnumAttribute.getIndexById("HP");
        for (int i = 0; i < 4; i++) {
            if (arthurList.get(i).isDead()) {
                continue;
            }
            if (arthurList.get(i).getBuffs().containsKey("HEAL") && !arthurList.get(i).getBuffs().get("HEAL").isEmpty()) {
                Integer val = arthurList.get(i).getBuffs().get("HEAL").get(0).getValue()[0];
                if (arthurList.get(i).getBuffs().containsKey("HEAL_REVERSE") && !arthurList.get(i).getBuffs().get("HEAL_REVERSE").isEmpty()) {
                    val = Math.min(val, arthurList.get(i).getCurrentAttr(hpIndex) - 1);
                    arthurList.get(i).changeCurrentAttr(-val, hpIndex);
                    arthurList.get(i).setDamageTaken(arthurList.get(i).getDamageTaken() + val);
                    arthurList.get(i).setDamageTakenNowTurn(arthurList.get(i).getDamageTakenNowTurn() + val);
                    sb.append(arthurList.get(i).getName()).append("受到").append(val).append("点伤害。（治疗反转）\n");
                } else {
                    arthurList.get(i).changeCurrentAttr(Math.min(val,
                            arthurList.get(i).getCurrentAttr(EnumAttribute.getIndexById("MAX_HP")) - arthurList.get(i).getCurrentAttr(hpIndex)), hpIndex);
                    sb.append(arthurList.get(i).getName()).append("的HP回复").append(val).append("点。\n");
                    // REGENERATE does NOT count into healing.                    
                    //arthurList.get(i).setHealTakenNowTurn(arthurList.get(i).getHealTakenNowTurn() + val.intValue());
                }

            }
        }
        if (sb.length() > 0) {
            sb.append("\n");
            txtBattleInfo.append(sb.toString());
            txtBattleInfo.setCaretPosition(txtBattleInfo.getText().length());
            refreshArthurUI();
            sleep(SLEEP_SHORT);
        }

        // Deal 
        String skillId;
        Boolean dealed, allDealed = false;
        for (int i = 0; i < 4; i++) {
            if (arthurList.get(i).isDead()) {
                continue;
            }
            arthurList.get(i).decreaseSealedTurns();
            dealed = false;
            arthurList.get(i).setCostUsed(0);
            sb = new StringBuilder();
            sb.append(EnumArthur.getNameByIndex(i)).append("抽卡：\n");
            for (int j = 0; j < dealCardQty[i]; j++) {
                skillId = arthurList.get(i).drawCard(turn);
                if (skillId != null) {
                    sb.append("【").append(arthurList.get(i).getDeck().get(skillId).getCardName()).append("】、");
                    dealed = true;
                    allDealed = true;
                }
            }
            if (dealed) {
                sb.deleteCharAt(sb.length() - 1).append("\n");
                txtBattleInfo.append(sb.toString());
            }
        }
        if (allDealed) {
            txtBattleInfo.append("\n");
            txtBattleInfo.setCaretPosition(txtBattleInfo.getText().length());
        }

        haltGame(false);
        computeChains();
        computeIsBoost();
        computeSkillValues();
        refreshArthurUI();
        refreshEnemyUI();
        for (int i = 0; i < 4; i++) {
            if (arStatusTButton.get(i).isSelected()) {
                refreshCardUI(i);
            }
        }

        recordTurnInfo();
    }

    private void sleep(Long time) {
        try {
            Thread.sleep(time);
        } catch (InterruptedException ex) {
            log.error(ex);
        }
    }

    private void processBuffs() {
        dealCardQty = new Integer[]{1, 1, 1, 1};
        for (ArthurInfo part : arthurList) {
            computeDealQty(part);
            processPartBuff(part);
        }
        for (int i = enemyList.size() - 1; i >= 0; i--) {
            processPartBuff(enemyList.get(i));
        }
    }

    private void processPartBuff(PartInfo part) {
        // Avoid concurrent modification problem.
        List<String> buffs = new ArrayList<>(part.getBuffs().keySet());
        for (String buffName : buffs) {
            for (int i = part.getBuffs().get(buffName).size() - 1; i >= 0; i--) {
                BuffInfo buff = part.getBuffs().get(buffName).get(i);
                //buff.setTurnLeft(buff.getTurnLeft() - 1);
                //log.info(part.getName() + " | " + buffName + " | " + buff);
                if (buff.getTurnLeft() + buff.getTurnSet() <= (turn + 1)) {
                    //if (buff.getTurnLeft().equals(0)) {
                    removeBuffEffectFromPart(buff, part);
                    part.getBuffs().get(buffName).remove(i);
                }
            }
        }
    }//(reg.getTurnSet() + reg.getTurnLeft() - 1) > turn)

    private Integer computeDotDamage(boolean isArthur) {
        Integer typeRate;
        Long damage;
        StringBuilder sb = new StringBuilder();;
        List<PartInfo> partList = new ArrayList<>();
        if (isArthur) {
            partList.addAll(arthurList);
        } else {
            partList.addAll(enemyList);
        }
        for (String dotName : EnumBuff.getDotNames()) {
            for (PartInfo part : partList) {
                if (part.getBuffs().containsKey(dotName) && !part.getBuffs().get(dotName).isEmpty()) {
//                    if (!part.isArthur() // NOTICE: simulate resistence, will change later.
//                            && (part.getBuffs().get(dotName).get(0).getTurnLeft() + part.getBuffs().get(dotName).get(0).getTurnSet() - 1 <= turn)) {
//                        continue;
//                    }
                    BuffInfo dot = part.getBuffs().get(dotName).get(0);
                    typeRate = part.getTypeRate()[dot.getValue()[1]];
                    if (typeRate == 100) {
                        typeRate = EnumType.getNormalRate(EnumType.getIdByIndex(dot.getValue()[1]), part.getType());
                    }
                    damage = dot.getValue()[0].longValue() * typeRate / 100;

                    if (!part.isDead()) {
                        part.setDamageTaken(part.getDamageTaken() + damage.intValue());
                        part.setDamageTakenNowTurn(part.getDamageTakenNowTurn() + damage.intValue());
                        part.changeCurrentAttr(-damage.intValue(), EnumAttribute.getIndexById("HP"));
                        sb.append(part.getName()).append("受到").append(damage).append("点").append(EnumType.getDotNameByIndex(dot.getValue()[1])).append("伤害。\n");
                        if (part.getCurrentAttr(EnumAttribute.getIndexById("HP")) < 0) {
                            part.changeCurrentAttr(-part.getCurrentAttr(EnumAttribute.getIndexById("HP")), EnumAttribute.getIndexById("HP"));
                            part.setDead(true);
                            part.setDeadCount(part.getDeadCount() + 1);
                            clearBuffsForDead(part);
                            sb.append(part.getName()).append("被击破！\n");
                            if (isWin() != 0) {
                                sb.append("\n");
                                txtBattleInfo.append(sb.toString());
                                txtBattleInfo.setCaretPosition(txtBattleInfo.getText().length());
                                sleep(SLEEP_SHORT);
                                return isWin();
                            }
                        }
                    }
                }
            }
        }
        if (sb.length() > 0) {
            sb.append("\n");
            txtBattleInfo.append(sb.toString());
            txtBattleInfo.setCaretPosition(txtBattleInfo.getText().length());
            sleep(SLEEP_SHORT);
        }
        return isWin();
    }

    private void computeDealQty(PartInfo part) {
        if (part.getBuffs().containsKey("DEAL_BONUS") && !part.getBuffs().get("DEAL_BONUS").isEmpty()) {
            dealCardQty[EnumArthur.getIndexByName(part.getName())] += part.getBuffs().get("DEAL_BONUS").get(0).getValue()[0];
        }
        if (part.getBuffs().containsKey("DEAL_PENALTY") && !part.getBuffs().get("DEAL_PENALTY").isEmpty()) {
            dealCardQty[EnumArthur.getIndexByName(part.getName())] += part.getBuffs().get("DEAL_PENALTY").get(0).getValue()[0];
        }
        log.debug(part.getName() + " deal qty = " + dealCardQty[EnumArthur.getIndexByName(part.getName())]);
    }

    private Integer processEnemySkill() {
        log.info("Start processEnemySkill.");
        txtBattleInfo.append("————————————————敌方行动————————————————\n\n");
        txtBattleInfo.setCaretPosition(txtBattleInfo.getText().length());
        sleep(SLEEP_SHORT);
        // Determine action play order.
        // Filter list is the 1st step, and action list is in reverse order of it (for same priority).
        List<EnemySkill> actionFilterList = new ArrayList<>();
        List<EnemySkill> actionList = new ArrayList<>();
        StringBuilder sb;
        sb = new StringBuilder();
        for (EnemyInfo enemy : enemyList) {
            if (enemy.isDead()) {
                continue;
            }
            if (enemy.getBuffs().containsKey("STAN") && enemy.getBuffs().get("STAN").isEmpty()) {
                sb.append(enemy.getName()).append("无法行动。\n");
                continue;
            }

            enemy.setCurrentActionPoint(enemy.getActionPoint());
            //actionList.addAll(enemy.getSkills());
            EnemySkill action;
            String[] enemyAiOrder;
            // The enemy skill is already sorted during prepare.
            for (int i = 0; i < enemy.getSkills().size(); i++) {
                action = enemy.getSkills().get(i);
                enemyAiOrder = enemyAiOrderMap.get(action.getAiOrderId());
                // Check cost and ai order conditions.
                if (enemy.getCurrentActionPoint() < action.getCost() || !aiOrderSatisfied(enemyAiOrder, enemy)
                        || action.getMaxTimes() <= 0) {
                    continue;
                }
                // Check success rate.
                if (Math.round(Math.random() * 100 + 0.5) > action.getSuccessRate()) {
                    continue;
                }
                // Spend action point and time used..
                enemy.setCurrentActionPoint(enemy.getCurrentActionPoint() - action.getCost());
                action.setMaxTimes(action.getMaxTimes() - 1);
                actionFilterList.add(action);
            }
        }
        if (sb.length() > 0) {
            sb.append("\n");
            txtBattleInfo.append(sb.toString());
            txtBattleInfo.setCaretPosition(txtBattleInfo.getText().length());
            sleep(SLEEP_SHORT);
        }

        for (int n = actionFilterList.size() - 1; n >= 0; n--) {
            actionList.add(actionFilterList.get(n));
        }
        // Re-order them.
        Collections.sort(actionList);

        for (EnemySkill action : actionList) {
//            String[] enemyAiOrder = enemyAiOrderMap.get(action.getAiOrderId());
//            enemy = enemyList.get(action.getEnemyIndex());
//            // Check cost and ai order conditions.
//            if (enemy.getCurrentActionPoint() < action.getCost() || !aiOrderSatisfied(enemyAiOrder, enemy)
//                    || action.getMaxTimes() <= 0) {
//                continue;
//            }
//            // Check success rate.
//            if (Math.round(Math.random() * 100 + 0.5) > action.getSuccessRate()) {
//                continue;
//            }
//
//            // Spend action point and time used..
//            enemy.setCurrentActionPoint(enemy.getCurrentActionPoint() - action.getCost());
//            action.setMaxTimes(action.getMaxTimes() - 1);

            sb = new StringBuilder();
            sb.append(enemyList.get(action.getEnemyIndex()).getName()).append(" 使用技能——\n");
            List<String[]> skills = skillMap.get(action.getSkillId());
            if (skills.get(0)[0].equals("1")) {
                sb.append("【无行动】\n");
            } else if (!skills.get(0)[1].isEmpty()) {
                sb.append("【").append(skills.get(0)[1]).append("】\n");
            }
            txtBattleInfo.append(sb.toString());

            executeSingleEnemySkill(action, skills);

            txtBattleInfo.append("\n");
            refreshArthurUI();
            refreshEnemyUI();
            txtBattleInfo.setCaretPosition(txtBattleInfo.getText().length());
            sleep(SLEEP_SHORT);

            // Check winning condition.
            if (isWin() == -1) {
                return -1;
            }

        }
        return 0;
    }

    public void executeSingleEnemySkill(EnemySkill action, List<String[]> skills) throws NumberFormatException {
        Integer cardLevel = 0, currentChain = 0;
        Integer boostPriority = 0;
        Integer[] target = determineEnemyTarget(action, skills.get(0)[18]);
        if (skills.size() > 1) {  // re-check boost skill , otherwise should be 0.
            for (int i = 1; i < skills.size(); i++) {
                boostPriority = Math.max(boostPriority, checkIsBoost(skills.get(i), action.getEnemyIndex(), false, target));
                log.debug("Skill: " + action.getSkillId() + " Priority: " + boostPriority);
            }
        }
        String[] boostedSkill = null;
        if (boostPriority > 0) {
            for (String[] aSkill : skills) {
                if (!aSkill[26].isEmpty() && Integer.parseInt(aSkill[26]) == boostPriority) {
                    boostedSkill = aSkill;
                }
            }
            if (boostedSkill == null) {
                log.error("ERROR.");
            } else {
                log.info("Execute Skill:" + skills.get(0)[0] + " | actual skill: " + boostedSkill[0] + " | boost: " + boostPriority
                        + " | cardLevel: " + cardLevel + " | chain: " + currentChain + " | enemy index: " + action.getEnemyIndex()
                        + " | target: " + Arrays.toString(target));
                executeSkill(skills.get(0), boostedSkill, cardLevel, currentChain,
                        action.getEnemyIndex(), target, false);
            }
        } else {
            log.info("Execute Skill:" + skills.get(0)[0] + " | actual skill: " + skills.get(0)[0] + " | boost: " + boostPriority
                    + " | cardLevel: " + cardLevel + " | chain: " + currentChain + " | enemy index: " + action.getEnemyIndex()
                    + " | target: " + Arrays.toString(target));
            executeSkill(skills.get(0), skills.get(0), cardLevel, currentChain,
                    action.getEnemyIndex(), target, false);
        }
    }

    /**
     * @return - Enemy's target, similar as user ones. Integer array w/ length
     * 2. [0]:0=user, 1=enemy, 2=dead enemy; [1]:, 0-3=single part, 4=all;
     */
    private Integer[] determineEnemyTarget(EnemySkill action, String targetSelected) {
        Integer[] returnVal = new Integer[]{-1, -1};

        switch (targetSelected) {
            case "SELF":
                return new Integer[]{1, action.getEnemyIndex()};
            case "USER_ONE":
                returnVal[0] = 0;
                break;
            case "USER_ALL":
                return new Integer[]{0, 4};
            case "ENEMY_ONE":
                returnVal[0] = 1;
                break;
            case "ENEMY_ALL":
                return new Integer[]{1, 4};
            case "DEAD_ENEMY_ONE":
                returnVal[0] = 2;
                break;
            case "DEAD_ENEMY_ALL":
                return new Integer[]{2, 4};
            default:
                log.error("ERROR.");
                break;
        }

        // Covering.
        for (ArthurInfo arthur : arthurList) {
            if (arthur.getBuffs().containsKey("COVERING") && !arthur.getBuffs().get("COVERING").isEmpty()) {
                returnVal[1] = arthur.getPartIndex();
                return returnVal;
            }
        }

        // Assume if target not exist, returns random (except covering.
        String targetText = action.getTarget();
        Boolean findDead = false;
        if (returnVal[0] == 2) {
            findDead = true;
        }
        if (targetText.equals("NULL")) {
            log.error("ERROR.");
            return null;
        } else if (targetText.equals("RANDOM")) {
            getRandomTarget(returnVal, findDead);
        } else if (EnumArthur.getIndexById(targetText) != -1) {
            returnVal[1] = EnumArthur.getIndexById(targetText);
            if (!arthurList.get(returnVal[1]).isDead().equals(findDead)) {
                getRandomTarget(returnVal, findDead);
            }
        } else if (targetText.matches("ENEMY[\\d]")) {
            returnVal[1] = Integer.parseInt(targetText.substring(5, 6)) - 1;
            if (!enemyList.get(returnVal[1]).isDead().equals(findDead)) {
                getRandomTarget(returnVal, findDead);
            }
        } else if (targetText.matches("RANDOM_EXCEPT_.*")) {
            String classId = targetText.substring(14);
            List<PartInfo> partList = new ArrayList<>();
            for (ArthurInfo part : arthurList) {
                if (part.isDead().equals(findDead) && !part.getId().equals(classId)) {
                    partList.add(part);
                }
            }
            if (partList.isEmpty()) {
                getRandomTarget(returnVal, findDead);
            } else {
                Long index = Math.round(Math.random() * partList.size() - 0.5);
                returnVal[1] = partList.get(index.intValue()).getPartIndex();
            }
        } else if (targetText.matches("HIGH.*") || targetText.matches("LOW.*")) {
            Integer compareVal;
            String[] splitText = targetText.split("_");
            Integer compareIndex = -1;
            List<PartInfo> partList = new ArrayList<>();
            if (splitText[0].equals("HIGH")) {
                compareVal = Integer.MIN_VALUE;
            } else if (splitText[0].equals("LOW")) {
                compareVal = Integer.MAX_VALUE;
            } else {
                compareVal = 0;
                log.error("ERROR: " + targetText);
            }
            if (splitText[splitText.length - 1].equals("USER")) {
                partList.addAll(arthurList);
            } else if (splitText[0].equals("ENEMY")) {
                partList.addAll(enemyList);
            } else {
                log.error("ERROR: " + targetText);
            }
            String attrText;
            if (splitText.length == 4) {
                attrText = splitText[1] + "_" + splitText[2];
            } else {
                attrText = splitText[1];
            }
            for (PartInfo part : partList) {
                if (splitText[0].equals("HIGH")) {
                    if (part.isDead().equals(findDead) && ((part.getCurrentAttr(EnumAttribute.getIndexById(attrText)) > compareVal)
                            || (part.getCurrentAttr(EnumAttribute.getIndexById(attrText)).equals(compareVal) && Math.random() > 0.5))) {
                        compareVal = part.getCurrentAttr(EnumAttribute.getIndexById(attrText));
                        compareIndex = part.getPartIndex();
                    }
                } else if (splitText[0].equals("LOW")) {
                    if (part.isDead().equals(findDead) && ((part.getCurrentAttr(EnumAttribute.getIndexById(attrText)) < compareVal)
                            || (part.getCurrentAttr(EnumAttribute.getIndexById(attrText)).equals(compareVal) && Math.random() > 0.5))) {
                        compareVal = part.getCurrentAttr(EnumAttribute.getIndexById(attrText));
                        compareIndex = part.getPartIndex();
                    }
                }
            }
            returnVal[1] = compareIndex;
        } else if (targetText.equals("WEAKNESS_USER") || targetText.equals("WEAKNESS_USER_NOT_FOR_RANDOM")) {
            for (ArthurInfo arthur : arthurList) {
                // Do NOT check dead -- as current game does.
                if (arthur.getBuffs().containsKey("WEAKNESS") && !arthur.getBuffs().get("WEAKNESS").isEmpty()) {
                    returnVal[1] = arthur.getPartIndex();
                }
            }
            if (returnVal[1].equals(-1)) {
                getRandomTarget(returnVal, findDead);
            }
        }

        // Should not happen.
        if (returnVal[1] == -1) {
            log.error("ERROR: " + targetText);
            return null;
        }
        return returnVal;
    }

    private void getRandomTarget(Integer[] returnVal, Boolean findDead) {
        List<PartInfo> partList = new ArrayList<>();
        switch (returnVal[0]) {
            case 0:
                for (ArthurInfo part : arthurList) {
                    if (part.isDead().equals(findDead)) {
                        partList.add(part);
                    }
                }
                break;
            case 1:
            case 2:
                for (EnemyInfo part : enemyList) {
                    if (part.isDead().equals(findDead)) {
                        partList.add(part);
                    }
                }
                break;
            default:
                log.error("ERROR.");
                return;
        }
        if (partList.isEmpty()) {
            log.error("ERROR.");
            return;
        }
        Long index = Math.round(Math.random() * partList.size() - 0.5);
        returnVal[1] = partList.get(index.intValue()).getPartIndex();
    }

    /**
     * @return - True if AI condition satisfied, false otherwise.
     */
    private boolean aiOrderSatisfied(String[] enemyAiOrder, EnemyInfo enemy) {
        //log.warn(enemyAiOrder[0]);
        String partCondition = enemyAiOrder[1];
        if (partCondition.contains("PARTS") && enemy.getParts() == null) {
            log.error("ERROR.");
            return false;
        }
        switch (partCondition) {
            case "PARTS_ALL_BREAK":
                for (EnemyInfo enemyPart : enemy.getParts()) {
                    if (!enemyPart.isDead()) {
                        return false;
                    }
                }
                break;
            case "PARTS_1_BREAK":
                if (!enemy.getParts().get(0).isDead()) {
                    return false;
                }
                break;
            case "PARTS_2_BREAK":
                if (!enemy.getParts().get(1).isDead()) {
                    return false;
                }
                break;
            case "PARTS_3_BREAK":
                if (!enemy.getParts().get(2).isDead()) {
                    return false;
                }
                break;
            case "PARTS_FULL":
                for (EnemyInfo enemyPart : enemy.getParts()) {
                    if (enemyPart.isDead()) {
                        return false;
                    }
                }
                break;
            case "NULL":
                break;
            default:
                break;
        }

        if (enemyAiOrder[2].matches("[\\d]+") && enemyAiOrder[3].matches("[\\d]+")) {
            Integer hpLowerLimit = Integer.parseInt(enemyAiOrder[2]);
            Integer hpHigherLimit = Integer.parseInt(enemyAiOrder[3]);
            Integer hp_per = enemy.getCurrentAttr(EnumAttribute.getIndexById("HP")) * 100 / enemy.getCurrentAttr(EnumAttribute.getIndexById("MAX_HP"));
            if (hp_per < hpLowerLimit || hp_per > hpHigherLimit) {
                return false;
            }
        }

        if (enemyAiOrder[4].matches("[\\d]+") && enemyAiOrder[5].matches("[\\d]+")) {
            Integer parentHpLowerLimit = Integer.parseInt(enemyAiOrder[4]);
            Integer parentHpHigherLimit = Integer.parseInt(enemyAiOrder[5]);
            EnemyInfo parent = enemyList.get(enemy.getParent());
            Integer hp_per = parent.getCurrentAttr(EnumAttribute.getIndexById("HP")) * 100 / parent.getCurrentAttr(EnumAttribute.getIndexById("MAX_HP"));
            if (hp_per < parentHpLowerLimit || hp_per > parentHpHigherLimit) {
                return false;
            }
        }

        Integer turnIndex;
        if (turn <= 10) {
            turnIndex = turn + 5;
        } else {
            turnIndex = (turn - 1) % 10 + 17;
        }
        if (!enemyAiOrder[turnIndex].equals("1")) {
            return false;
        }

        String triggerType = enemyAiOrder[27];
        switch (triggerType) {
            case "AI_FLAG":
                if (!enemyTriggerAiFlag.containsKey(enemyAiOrder[28])
                        || !enemyTriggerAiFlag.get(enemyAiOrder[28]).equals(1)) {
                    return false;
                }
                break;
            case "BAD_STATUS":
                log.error("Error.");
                break;
            case "DAMAGE":
                if ((enemy.getpDamageTakenNowTurn() + enemy.getmDamageTakenNowTurn() + enemy.geteDamageTakenNowTurn(null)) < Integer.parseInt(enemyAiOrder[28])) {
                    return false;
                }
                break;
            case "DEAD_COUNT":
                Integer enemyIndex = Integer.parseInt(enemyAiOrder[28].substring(5, 6)) - 1;
                Integer minDeadCount = Integer.parseInt(enemyAiOrder[29]);
                Integer maxDeadCount = 999;
                if (enemyAiOrder.length > 30 && enemyAiOrder[30].matches("[\\d]+")
                        && Integer.parseInt(enemyAiOrder[30]) != 0 && Integer.parseInt(enemyAiOrder[29]) == 0) {     // MAY have bug
                    maxDeadCount = Integer.parseInt(enemyAiOrder[30]);
                }
                if (enemyList.get(enemyIndex).getDeadCount() < minDeadCount || enemyList.get(enemyIndex).getDeadCount() >= maxDeadCount) {
                    return false;
                }
                break;
            case "ENEMY_DEAD":
                for (int i = 0; i < 3; i++) {
                    if (enemyAiOrder.length > 28 + i && enemyAiOrder[28 + i].contains("ENEMY")) {
                        if (!enemyList.get(Integer.parseInt(enemyAiOrder[28 + i].substring(5, 6)) - 1).isDead()) {
                            return false;
                        }
                    }
                }
                break;
            case "HEAL_TOTAL":
                Integer totalHeal = 0;
                for (ArthurInfo arthur : arthurList) {
                    totalHeal += arthur.getHealTakenNowTurn();
                }
                if (totalHeal < Integer.parseInt(enemyAiOrder[28])) {
                    return false;
                }
                break;
            case "MAGIC_DAMAGE":
                if (enemy.getmDamageTakenNowTurn() + enemy.geteDamageTakenNowTurn(null) < Integer.parseInt(enemyAiOrder[28])) {
                    return false;
                }
                break;
            case "ENCHANT_DAMAGE":
                if (enemy.geteDamageTakenNowTurn(EnumType.getIndexById(enemyAiOrder[28])) < Integer.parseInt(enemyAiOrder[29])) {
                    return false;
                }
                break;
            case "MAGIC_DAMAGE_LARGE":
                if ((enemy.getmDamageTakenNowTurn() - enemy.getpDamageTakenNowTurn()) < Integer.parseInt(enemyAiOrder[28])) {
                    return false;
                }
                break;
            case "NOT_TARGET":
                if (enemy.getmDamageTakenNowTurn() > 0 || enemy.getmDamageTakenNowTurn() > 0 || enemy.geteDamageTakenNowTurn(null) > 0) {
                    return false;
                }
                break;
            case "PHYSIC_DAMAGE":
                if (enemy.getpDamageTakenNowTurn() + enemy.geteDamageTakenNowTurn(null) < Integer.parseInt(enemyAiOrder[28])) {
                    return false;
                }
                break;
            case "PHYSIC_DAMAGE_LARGE":
                if ((enemy.getpDamageTakenNowTurn() - enemy.getmDamageTakenNowTurn()) < Integer.parseInt(enemyAiOrder[28])) {
                    return false;
                }
                break;
            case "SKILL_ROLE_KIND_DEBUFF":
                Boolean hasBuff = false;
                for (int i = 0; i < 3; i++) {
                    if (enemyAiOrder.length > (28 + i)) {
                        String buffName = enemyAiOrder[28 + i];
                        if (enemy.getBuffs().containsKey(buffName) && !enemy.getBuffs().get(buffName).isEmpty()) {
                            hasBuff = true;
                        }
                    }
                }
                if (!hasBuff) {
                    return false;
                }
                break;
            case "SKILL_ROLE_KIND_DEBUFF_BY_USER":
                hasBuff = false;
                for (int i = 0; i < 3; i++) {
                    if (enemyAiOrder.length > (28 + i)) {
                        String buffName = enemyAiOrder[28 + i];
                        for (ArthurInfo arthur : arthurList) {
                            if (arthur.getBuffs().containsKey(buffName) && !arthur.getBuffs().get(buffName).isEmpty()) {
                                hasBuff = true;
                            }
                        }
                    }
                }
                if (!hasBuff) {
                    return false;
                }
                break;
            case "SKILL_ROLE_KIND_DEBUFF_NOW_TURN":
                hasBuff = false;
                for (int i = 0; i < 3; i++) {
                    if (enemyAiOrder.length > (28 + i)) {
                        String buffName = enemyAiOrder[28 + i];
                        if (enemy.getBuffs().containsKey(buffName)) {
                            for (BuffInfo buff : enemy.getBuffs().get(buffName)) {
                                if (buff.getTurnSet().equals(turn)) {
                                    hasBuff = true;
                                }
                            }
                        }
                    }
                }
                if (!hasBuff) {
                    return false;
                }
                break;
            case "SKILL_ROLE_KIND_BUFF_NOW_TURN_BY_USER":
                hasBuff = false;
                for (int i = 0; i < 3; i++) {
                    if (enemyAiOrder.length > (28 + i)) {
                        String buffName = enemyAiOrder[28 + i];
                        for (ArthurInfo arthur : arthurList) {
                            if (arthur.getBuffs().containsKey(buffName)) {
                                for (BuffInfo buff : arthur.getBuffs().get(buffName)) {
                                    if (buff.getTurnSet().equals(turn)) {
                                        hasBuff = true;
                                    }
                                }
                            }
                        }
                    }
                }
                if (!hasBuff) {
                    return false;
                }
                break;
            case "SKILL_ROLE_KIND_BUFF_BY_USER":
                hasBuff = false;
                for (int i = 0; i < 3; i++) {
                    if (enemyAiOrder.length > (28 + i)) {
                        String buffName = enemyAiOrder[28 + i];
                        for (ArthurInfo arthur : arthurList) {
                            if (arthur.getBuffs().containsKey(buffName) && !arthur.getBuffs().get(buffName).isEmpty()) {
                                hasBuff = true;
                            }
                        }
                    }
                }
                if (!hasBuff) {
                    return false;
                }
                break;
            case "DECK_COMBO_COUNT":
                Integer lowerLimit = Integer.parseInt(enemyAiOrder[28]);
                Integer upperLimit = Integer.parseInt(enemyAiOrder[29]);
                if ((deckComboCount + 1) < lowerLimit || (deckComboCount + 1) > upperLimit) {
                    return false;
                }
                break;
            case "DAMAGE_NUM":
                Integer damageType = EnumPhysicsMagic.getIndexById(enemyAiOrder[28]);
                lowerLimit = Integer.parseInt(enemyAiOrder[29]);
                upperLimit = Integer.parseInt(enemyAiOrder[30]);
                Integer damageNum = enemy.getDamageNumNowTurn(damageType);
                if (damageNum < lowerLimit || damageNum > upperLimit) {
                    return false;
                }
            case "NULL":
                break;
            default:
                txtBattleInfo.append("Unrecognized Trigger: " + triggerType + "\n");
                txtBattleInfo.setCaretPosition(txtBattleInfo.getText().length());
                break;
        }

        return true;
    }

    /**
     *
     * @return 0 if continue, -1 if break.
     */
    private Integer processArthurSkill() {
        log.info("Start processArthurSkill.");
        // Determine action play order.
        List<HandCardInfo> actionList = new ArrayList<>();
        for (ArthurInfo arthur : arthurList) {
            for (HandCardInfo card : arthur.getCurrentPlayedItem()) {
                log.debug("Prepare skill: " + card.getSkillId());
//                if (skillMap.get(card.getSkillId()).get(card.getBoostPriority())[14].matches("[\\d+]")) {
//                    card.setCardSkillPriority(Integer.parseInt(skillMap.get(card.getSkillId()).get(card.getBoostPriority())[14]));
//                } else {
                card.setCardSkillPriority(Integer.parseInt(skillMap.get(card.getSkillId()).get(0)[14]));
//                }
                actionList.add(card);
            }
        }
        // Shuffle the 'cards'.
        long n = actionList.size();
        HandCardInfo temp;
        for (int i = 0; i < n; i++) {
            Integer index = ((Long) Math.round(Math.random() * (n - i) - 0.5 + i)).intValue();
            if (index != i) {
                temp = actionList.get(i);
                actionList.set(i, actionList.get(index));
                actionList.set(index, temp);
            }
        }
        // Re-order them.
        actionList.sort(Constants.HAND_CARD_CMP);
        sortCardOrderWithSamePriority(actionList);

        // Compute arthur turn values
        for (HandCardInfo action : actionList) {
            if (action.getCurrentChain() > deckComboCount) {
                deckComboCount = action.getCurrentChain();
            }
        }

        txtBattleInfo.append("————————————————我方行动————————————————\n\n");
        txtBattleInfo.setCaretPosition(txtBattleInfo.getText().length());
        sleep(SLEEP_SHORT);
        StringBuilder sb;
        Integer cardLevel;
        for (HandCardInfo action : actionList) {
            sb = new StringBuilder();
            sb.append(EnumArthur.getNameByIndex(action.getSkill().getArthurIndex())).append(" 使用");
            if (action.getSkill().isSphere()) {
                sb.append("SPHERE：【");
            } else {
                sb.append("卡牌：【");
            }
            sb.append(action.getSkill().getCardName()).append("】（").append(action.getCurrentChain() + 1).append("Chain）\n");
            if (action.getSkill().getDialogue() != null && !action.getSkill().getDialogue().isEmpty()) {
                sb.append("『").append(action.getSkill().getDialogue()).append("』\n");
            }
            txtBattleInfo.append(sb.toString());

            // Re-determine isBoost. (Chain is fixed, but isBoost may change)
            List<String[]> skills = skillMap.get(action.getSkillId());
            if (skills.size() != 1) {  // re-check boost skill , otherwise should be 0.
                action.setBoostPriority(checkIsBoost(skills.get(skills.size() - 1), action.getSkill().getArthurIndex(), true, action.getTarget()));
            }
            cardLevel = EnumCardLevel.getLevel(action.getSkill().getRarity());

            log.info("Execute Skill:" + skills.get(0)[0] + " | actual skill: " + skills.get(action.getBoostPriority())[0] + " | boost: " + action.getBoostPriority()
                    + " | cardLevel: " + cardLevel + " | chain: " + action.getCurrentChain() + " | arthur index: " + action.getSkill().getArthurIndex()
                    + " | target: " + Arrays.toString(action.getTarget()));
            executeSkill(skills.get(0), skills.get(action.getBoostPriority()), cardLevel, action.getCurrentChain(),
                    action.getSkill().getArthurIndex(), action.getTarget(), true);

            txtBattleInfo.append("\n");
            refreshArthurUI();
            refreshEnemyUI();
            txtBattleInfo.setCaretPosition(txtBattleInfo.getText().length());
            sleep(SLEEP_SHORT);

            // Check winning condition.
            if (isWin() == 1) {
                return 1;
            }

        }

        // Remove all played handcards.
        sb = new StringBuilder();
        for (HandCardInfo action : actionList) {
            ArthurInfo arthur = arthurList.get(action.getSkill().getArthurIndex());
            if (action.getIsTrapped() > 0) {
                Integer damage = Math.min(arthur.getCurrentAttr(EnumAttribute.getIndexById("HP")) - 1, action.getIsTrapped());
                arthur.changeCurrentAttr(-damage, EnumAttribute.getIndexById("HP"));
                arthur.setDamageTaken(arthur.getDamageTaken() + damage);
                arthur.setDamageTakenNowTurn(arthur.getDamageTakenNowTurn() + damage);
                // Remove the trap (and probably the debuff).
                for (int i = arthur.getBuffs().get("CARD_TRAP_DAMAGE").size() - 1; i >= 0; i--) {
                    BuffInfo buffInfo = arthur.getBuffs().get("CARD_TRAP_DAMAGE").get(i);
                    if (buffInfo.getValue()[action.getHandPosition()] == 1) {
                        buffInfo.getValue()[action.getHandPosition()] = 0;
                        if (buffInfo.getValue()[0] == 0 && buffInfo.getValue()[1] == 0
                                && buffInfo.getValue()[2] == 0 && buffInfo.getValue()[3] == 0 && buffInfo.getValue()[4] == 0) {
                            arthur.getBuffs().get("CARD_TRAP_DAMAGE").remove(i);
                        }
                    }
                }
                sb.append(arthur.getName()).append("受到").append(damage).append("点卡牌陷阱伤害。\n");
            }
            if (!action.getSkill().isSphere()) {
                arthur.playCard(action.getHandPosition());
            } else {
                arthur.playSphere(action.getHandPosition());
            }
        }
        if (sb.length() > 0) {
            sb.append("\n");
            txtBattleInfo.append(sb.toString());
            txtBattleInfo.setCaretPosition(txtBattleInfo.getText().length());
            refreshArthurUI();
            sleep(SLEEP_SHORT);
        }

        for (int i = 0; i < 4; i++) {
            arthurList.get(i).getCurrentPlayedItem().clear();
        }
        return 0;
    }

    private void executeSkill(String[] skillBase, String[] skill, Integer cardLevel, Integer chain, Integer partIndex, Integer[] target, boolean isArthur) {
        //log.info("Execute Skill:" + skill[0] + " | cardLevel: " + cardLevel + " | cardLevel: " + cardLevel + " | cardLevel: " + cardLevel);
        PartInfo part;
        BuffInfo buff;
        if (isArthur) {
            part = arthurList.get(partIndex);
        } else {
            part = enemyList.get(partIndex);
        }

        List<PartInfo> targetParts = new ArrayList<>();
        List<PartInfo> realTargetParts;
        Boolean aimDead = false;
        if (target[0] == 2) {
            aimDead = true;
        }
        if (target[0] == 0) {
            if (target[1] != 4) {
                targetParts.add(arthurList.get(target[1]));
            } else {
                targetParts.addAll(arthurList);
            }
        } else if (target[0] == 1 || target[0] == 2) {
            if (target[1] != 4) {
                targetParts.add(enemyList.get(target[1]));
            } else {
                targetParts.addAll(enemyList);
            }
        } else {
            log.error("ERROR.");
        }

        Long chainBoostVal = 0L;
        if (!skill[19].isEmpty()) {
            chainBoostVal = Long.parseLong(skill[19]);
        }

        //Integer[] attr = part.getCurrentAttr();
        Long val;
        Integer atkOpVal = 0;
        boolean rateDownInvalid = false;
        Integer drainRate = 0;
        Integer defencePiercing = 0;
        StringBuilder sb;
        List<String[]> skillRoleList = skillRoleMap.get(skill[27]);
        for (String[] skillRole : skillRoleList) {
            if (skillRole[SKILL_ROLE_TARGET].equals("SELECT")) {
                realTargetParts = targetParts;
            } else if (skillRole[SKILL_ROLE_TARGET].equals("ENEMY_ALL")) {
                realTargetParts = new ArrayList<>();
                realTargetParts.addAll(enemyList);
            } else if (skillRole[SKILL_ROLE_TARGET].equals("FRIEND_ALL")) {
                realTargetParts = new ArrayList<>();
                realTargetParts.addAll(arthurList);
            } else if (skillRole[SKILL_ROLE_TARGET].equals("SELF")) {
                realTargetParts = new ArrayList<>();
                realTargetParts.add(part);
            } else {
                realTargetParts = new ArrayList<>();
                log.error("ERROR.");
            }
            // Re-determine target.
            // It is fine for enemy to choose a dead arthur (weakness or cover).
            if (realTargetParts.size() == 1) {
                if (!realTargetParts.get(0).isDead().equals(aimDead)) {
                    if (!part.isArthur()) {
//                    if (!part.isArthur() && realTargetParts.get(0).isArthur()
//                            && ((realTargetParts.get(0).getBuffs().containsKey("WEAKNESS") && !realTargetParts.get(0).getBuffs().get("WEAKNESS").isEmpty())
//                            || (realTargetParts.get(0).getBuffs().containsKey("COVERING") && !realTargetParts.get(0).getBuffs().get("COVERING").isEmpty()))) {
                        // Do not choose another target, as target for enemy is just determined.
                    } else {                    // Choose another target.
                        List<PartInfo> newTargetParts = new ArrayList<>();
                        if (realTargetParts.get(0).isArthur()) {
                            for (ArthurInfo newTarget : arthurList) {
                                if (newTarget.isDead().equals(aimDead)) {
                                    newTargetParts.add(newTarget);
                                }
                            }
                        } else {
                            for (EnemyInfo newTarget : enemyList) {
                                if (newTarget.isDead().equals(aimDead)) {
                                    newTargetParts.add(newTarget);
                                }
                            }
                        }
                        if (newTargetParts.isEmpty()) {
                            log.error("No available target. Action cancelled for skillRole: " + skillRole[0]);
                            continue;   // or break?
                        } else {
                            Long newTargetIndex = Math.round(Math.random() * newTargetParts.size() - 0.5);
                            realTargetParts.clear();
                            realTargetParts.add(newTargetParts.get(newTargetIndex.intValue()));
                            log.info("Target changed: " + realTargetParts.get(0).getName());
                        }
                    }
                }
            } else {
                // Remove dead parts (or alive parts, if skillrole = revive).
                for (int i = realTargetParts.size() - 1; i >= 0; i--) {
                    if (!realTargetParts.get(i).isDead().equals(aimDead)) {
                        realTargetParts.remove(i);
                    }
                }
            }

            switch (skillRole[SKILL_ROLE_FUNCTION_COL]) {
                case "NONE":
                // DO NOTHING.
                case "OUTPUT_TEXT":
                    // DO NOTHING.
                    break;
                case "ATK_OP_DAMAGE_INCREASE":
                    Integer attrVal = part.getCurrentAttr(EnumAttribute.getIndexById(skillRole[SKILL_ROLE_PARAM5]));
                    val = Long.parseLong(skillRole[SKILL_ROLE_PARAM3]) * attrVal / 1000;
                    atkOpVal += val.intValue();
                    log.info("val: " + val + " | atkOpVal: " + atkOpVal);
                    break;
                case "ATK_OP_REVENGE":
                    val = Long.parseLong(skillRole[SKILL_ROLE_PARAM1]) * part.getDamageTaken() / 100;
                    if (val > part.getCurrentAttr(EnumAttribute.getIndexById(skillRole[SKILL_ROLE_PARAM3])) * Long.parseLong(skillRole[SKILL_ROLE_PARAM4]) / 100) {
                        val = part.getCurrentAttr(EnumAttribute.getIndexById(skillRole[SKILL_ROLE_PARAM3])) * Long.parseLong(skillRole[SKILL_ROLE_PARAM4]) / 100;
                    }
                    atkOpVal += val.intValue();
                    break;
                case "ATK_OP_NOW_TURN_REVENGE":
                    val = Long.parseLong(skillRole[SKILL_ROLE_PARAM1]) * part.getDamageTakenNowTurn() / 100;
                    if (val > part.getCurrentAttr(EnumAttribute.getIndexById(skillRole[SKILL_ROLE_PARAM3])) * Long.parseLong(skillRole[SKILL_ROLE_PARAM4]) / 100) {
                        val = part.getCurrentAttr(EnumAttribute.getIndexById(skillRole[SKILL_ROLE_PARAM3])) * Long.parseLong(skillRole[SKILL_ROLE_PARAM4]) / 100;
                    }
                    atkOpVal += val.intValue();
                    break;
                case "ATK_OP_ATTR_RATE_DOWN_INVALID":
                    rateDownInvalid = true;
                    break;
                case "ATK_OP_DRAIN":
                    drainRate = Integer.parseInt(skillRole[SKILL_ROLE_PARAM1]) + cardLevel * Integer.parseInt(skillRole[SKILL_ROLE_PARAM2]);
                    break;
                case "ATK_OP_PIERCING":
                    defencePiercing = Integer.parseInt(skillRole[SKILL_ROLE_PARAM1]) + cardLevel * Integer.parseInt(skillRole[SKILL_ROLE_PARAM2]);
                    break;
                case "REVIVE":
                    for (PartInfo targetPart : realTargetParts) {
                        //Integer[] currentAttr = targetPart.getCurrentAttr();
                        val = Long.parseLong(skillRole[SKILL_ROLE_PARAM1]) * targetPart.getCurrentAttr(EnumAttribute.getIndexById("MAX_HP")) / 1000;
                        targetPart.changeCurrentAttr(val.intValue(), EnumAttribute.getIndexById("HP"));
                        sb = new StringBuilder();
                        sb.append(getTargetName(realTargetParts)).append("复活，并回复").append(Long.parseLong(skillRole[SKILL_ROLE_PARAM1]) / 10).append("％HP。\n");
                        txtBattleInfo.append(sb.toString());
                    }
                    break;
                case "ATTACK_AA":
                    attrVal = part.getCurrentAttr(EnumAttribute.getIndexById(skillRole[SKILL_ROLE_PARAM6]));
                    val = atkOpVal + Long.parseLong(skillRole[SKILL_ROLE_PARAM1]) + Long.parseLong(skillRole[SKILL_ROLE_PARAM2]) * cardLevel / 1000;
                    val += Long.parseLong(skillRole[SKILL_ROLE_PARAM3]) * attrVal / 1000;
                    Integer critRate = part.getCurrentAttr(EnumAttribute.getIndexById("CRIT")) + Integer.parseInt(skillRole[SKILL_ROLE_PARAM7]);
                    String[] atkTypeArray = skillRole[SKILL_ROLE_PARAM8].split("_");
                    String physics = skillRole[SKILL_ROLE_PARAM9];
                    Integer attackTimes = Integer.parseInt(skillRole[SKILL_ROLE_PARAM5]);
                    Long defence;
                    Integer typeRate;
                    Integer critDamageRate;
                    Integer damamgeReductionRate;
                    Long totalDamage = 0L;
                    Integer weaknessRate;
                    for (PartInfo targetPart : realTargetParts) {
                        typeRate = 0;
                        defence = targetPart.getCurrentAttr(EnumAttribute.getIndexById(EnumPhysicsMagic.getDefIdById(physics))).longValue();
                        if (defencePiercing > 0) {
                            defence = Math.min(defence, defence * (100 - defencePiercing) / 100);
                        }
                        for (String atkTypeStr : atkTypeArray) {
                            Integer tempRate = targetPart.getTypeRate()[EnumType.getIndexById(atkTypeStr)];
                            if (tempRate.equals(100)) {
                                tempRate = EnumType.getNormalRate(atkTypeStr, targetPart.getType());
                            }
                            if (tempRate > typeRate) {
                                typeRate = tempRate;
                            }
                        }
                        if (rateDownInvalid && typeRate < 100) {
                            typeRate = 100;
                        }
                        weaknessRate = 100;
                        if (targetPart.getBuffs().containsKey("WEAKNESS")
                                && !targetPart.getBuffs().get("WEAKNESS").isEmpty()) {
                            weaknessRate += targetPart.getBuffs().get("WEAKNESS").get(0).getValue()[0];
                        }
                        damamgeReductionRate = 100 - targetPart.getCurrentAttr(EnumAttribute.getIndexById("DDUC"));

                        for (int i = 0; i < attackTimes; i++) {
                            critDamageRate = 100;
                            if (Math.round(Math.random() * 100 + 0.5) <= critRate) {
                                critDamageRate = 150;
                            }
                            log.info("ATTR：" + part.getCurrentAttrStr());
                            log.info("AtkOpVal：" + atkOpVal + " | drainRate：" + drainRate + " | defencePiercing：" + defencePiercing + " | rateDownInvalid：" + rateDownInvalid);
                            log.info("Orig val: " + val + " | critDamageRate: " + critDamageRate + " | critRate: " + critRate
                                    + " | typeRate: " + typeRate + " | weaknessRate: " + weaknessRate
                                    + " | defence: " + defence + " | damamgeReductionRate: " + damamgeReductionRate
                                    + " | chainBoostVal: " + chainBoostVal + " | chain: " + chain);
                            Long damage = val * critDamageRate / 100 * typeRate / 100 * weaknessRate / 100;
                            damage = damage * (100 + chainBoostVal * chain) / 100 - defence;
                            damage = damage * damamgeReductionRate / 100;
                            if (damage <= 0) {
                                damage = 1L;
                            }
                            if (targetPart.getBuffs().containsKey("ATTACK_BARRIER")
                                    && !targetPart.getBuffs().get("ATTACK_BARRIER").isEmpty()) {
                                Integer[] value = targetPart.getBuffs().get("ATTACK_BARRIER").get(0).getValue();
                                if (value[2].equals(EnumPhysicsMagic.getIndexById(physics)) && value[1] > 0) {
                                    value[1]--;
                                    if (value[0] > damage) {
                                        damage = 0L;
                                    }
                                }
                            }

                            totalDamage += damage;
                            targetPart.setDamageTaken(targetPart.getDamageTaken() + damage.intValue());
                            targetPart.setDamageTakenNowTurn(targetPart.getDamageTakenNowTurn() + damage.intValue());
                            Integer damageTypeIndex = EnumPhysicsMagic.getIndexById(physics);
                            targetPart.setDamageNumNowTurn(targetPart.getDamageNumNowTurn(damageTypeIndex) + 1, damageTypeIndex);
                            if (physics.equals("PHYSICS")) {
                                targetPart.setpDamageTakenNowTurn(targetPart.getpDamageTakenNowTurn() + damage.intValue());
                            } else {
                                targetPart.setmDamageTakenNowTurn(targetPart.getmDamageTakenNowTurn() + damage.intValue());
                            }

                            sb = new StringBuilder();
                            if (critDamageRate.equals(150)) {
                                sb.append("暴击！");
                            }
                            sb.append("对").append(targetPart.getName()).append("造成").append(damage).append("点");
                            for (String atkTypeStr : atkTypeArray) {
                                sb.append(EnumType.getNameById(atkTypeStr));
                            }
                            sb.append("属性").append(EnumPhysicsMagic.getNameById(physics)).append("伤害。");
                            if (typeRate > 100) {
                                sb.append("（效果良好）");
                            } else if (typeRate < 100) {
                                sb.append("（效果不佳）");
                            }
                            if (weaknessRate > 100) {
                                if (sb.indexOf("）") == -1) {
                                    sb.append("（被标记）");
                                } else {
                                    sb.deleteCharAt(sb.length() - 1);
                                    sb.append("，被标记）");
                                }
                            }
                            if (damage.equals(0)) {
                                if (sb.indexOf("）") == -1) {
                                    sb.append("（被吸收）");
                                } else {
                                    sb.deleteCharAt(sb.length() - 1);
                                    sb.append("，被吸收）");
                                }
                            }
                            sb.append("\n");
                            txtBattleInfo.append(sb.toString());

                            if (targetPart.getBuffs().containsKey("ATTACK_BARRIER")
                                    && !targetPart.getBuffs().get("ATTACK_BARRIER").isEmpty()
                                    && targetPart.getBuffs().get("ATTACK_BARRIER").get(0).getValue()[1] == 0) {
                                targetPart.getBuffs().get("ATTACK_BARRIER").clear();
                                txtBattleInfo.append("护盾被击破！\n");
                            }

                            if (!targetPart.isDead()) {
                                targetPart.changeCurrentAttr(-damage.intValue(), EnumAttribute.getIndexById("HP"));

                                if (targetPart.getCurrentAttr(EnumAttribute.getIndexById("HP")) < 0) {
                                    targetPart.changeCurrentAttr(-targetPart.getCurrentAttr(EnumAttribute.getIndexById("HP")), EnumAttribute.getIndexById("HP"));
                                    targetPart.setDead(true);
                                    clearBuffsForDead(targetPart);
                                    targetPart.setDeadCount(targetPart.getDeadCount() + 1);
                                    sb = new StringBuilder();
                                    sb.append(targetPart.getName()).append("被击破！\n");
                                    txtBattleInfo.append(sb.toString());
                                }
                            }

                            applyDamageToParent(targetPart, damage);

                            // Enchant
                            if (part.getBuffs().containsKey("ENCHANT")
                                    && !part.getBuffs().get("ENCHANT").isEmpty()) {
                                BuffInfo enchant = part.getBuffs().get("ENCHANT").get(0);
                                Integer enchTypeRate = targetPart.getTypeRate()[enchant.getValue()[1]];
                                if (enchTypeRate.equals(100)) {
                                    enchTypeRate = EnumType.getNormalRate(EnumType.getIdByIndex(enchant.getValue()[1]), targetPart.getType());
                                }
                                Long enchDamage = enchant.getValue()[0].longValue() * enchTypeRate / 100 * weaknessRate / 100;
                                if (targetPart.getBuffs().containsKey("ATTACK_BARRIER")
                                        && !targetPart.getBuffs().get("ATTACK_BARRIER").isEmpty()) {
                                    Integer[] value = targetPart.getBuffs().get("ATTACK_BARRIER").get(0).getValue();
                                    if (value[1] > 0) {
                                        value[1]--;
                                        if (value[0] > enchDamage) {
                                            enchDamage = 0L;
                                        }
                                    }
                                }
                                totalDamage += enchDamage;
                                targetPart.setDamageTaken(targetPart.getDamageTaken() + enchDamage.intValue());
                                targetPart.setDamageTakenNowTurn(targetPart.getDamageTakenNowTurn() + enchDamage.intValue());
                                targetPart.seteDamageTakenNowTurn(targetPart.geteDamageTakenNowTurn(enchant.getValue()[1]) + enchDamage.intValue(), enchant.getValue()[1]);
                                damageTypeIndex = EnumPhysicsMagic.getIndexById("ENCHANT");
                                targetPart.setDamageNumNowTurn(targetPart.getDamageNumNowTurn(damageTypeIndex) + 1, damageTypeIndex);
                                
                                sb = new StringBuilder();
                                sb.append("对").append(targetPart.getName()).append("造成").append(enchDamage).append("点").
                                        append(EnumType.getNameByIndex(enchant.getValue()[1])).append("属性追加伤害。");
                                if (enchTypeRate > 100) {
                                    sb.append("（效果良好）");
                                } else if (enchTypeRate < 100) {
                                    sb.append("（效果不佳）");
                                }
                                if (weaknessRate > 100) {
                                    if (sb.indexOf("）") == -1) {
                                        sb.append("（被标记）");
                                    } else {
                                        sb.deleteCharAt(sb.length() - 1);
                                        sb.append("，被标记）");
                                    }
                                }
                                if (enchDamage.equals(0)) {
                                    if (sb.indexOf("）") == -1) {
                                        sb.append("（被吸收）");
                                    } else {
                                        sb.deleteCharAt(sb.length() - 1);
                                        sb.append("，被吸收）");
                                    }
                                }
                                sb.append("\n");
                                txtBattleInfo.append(sb.toString());

                                if (targetPart.getBuffs().containsKey("ATTACK_BARRIER")
                                        && !targetPart.getBuffs().get("ATTACK_BARRIER").isEmpty()
                                        && targetPart.getBuffs().get("ATTACK_BARRIER").get(0).getValue()[1] == 0) {
                                    targetPart.getBuffs().get("ATTACK_BARRIER").clear();
                                    txtBattleInfo.append("护盾被击破！\n");
                                }

                                if (!targetPart.isDead()) {
                                    targetPart.changeCurrentAttr(-enchDamage.intValue(), EnumAttribute.getIndexById("HP"));

                                    if (targetPart.getCurrentAttr(EnumAttribute.getIndexById("HP")) < 0) {
                                        targetPart.changeCurrentAttr(-targetPart.getCurrentAttr(EnumAttribute.getIndexById("HP")), EnumAttribute.getIndexById("HP"));
                                        targetPart.setDead(true);
                                        clearBuffsForDead(targetPart);
                                        targetPart.setDeadCount(targetPart.getDeadCount() + 1);
                                        sb = new StringBuilder();
                                        sb.append(targetPart.getName()).append("被击破！\n");
                                        txtBattleInfo.append(sb.toString());
                                    }
                                }

                                applyDamageToParent(targetPart, enchDamage);
                            }
                        }
                    }
                    if (drainRate > 0) {
                        Long drainDamage = totalDamage * drainRate / 100;
                        Integer hpMissing = part.getCurrentAttr(EnumAttribute.getIndexById("MAX_HP")) - part.getCurrentAttr(EnumAttribute.getIndexById("HP"));
                        part.changeCurrentAttr(Math.min(drainDamage.intValue(), hpMissing), EnumAttribute.getIndexById("HP"));
                        sb = new StringBuilder();
                        sb.append(part.getName()).append("通过伤害吸取回复了").append(drainDamage).append("点HP。\n");
                        txtBattleInfo.append(sb.toString());
                    }
                    break;
                case "HP_CUT":
                    for (PartInfo targetPart : realTargetParts) {
                        //Integer[] currentAttr = targetPart.getCurrentAttr();
                        val = Long.parseLong(skillRole[SKILL_ROLE_PARAM1]) * targetPart.getCurrentAttr(EnumAttribute.getIndexById("HP")) / 100;
                        if (val >= targetPart.getCurrentAttr(EnumAttribute.getIndexById("HP"))) {
                            val = targetPart.getCurrentAttr(EnumAttribute.getIndexById("HP")) - 1L;
                        }
                        targetPart.changeCurrentAttr(-val.intValue(), EnumAttribute.getIndexById("HP"));
                        targetPart.setDamageTaken(targetPart.getDamageTaken() + val.intValue());
                        targetPart.setDamageTakenNowTurn(targetPart.getDamageTakenNowTurn() + val.intValue());
                        sb = new StringBuilder();
                        sb.append(getTargetName(realTargetParts)).append("扣除").append(Long.parseLong(skillRole[SKILL_ROLE_PARAM1])).append("%当前HP。\n");
                        txtBattleInfo.append(sb.toString());
                    }
                    break;
                case "ATK_UP_FIXED":
                    executeAttrChangeFixed(skillRole, cardLevel, chain, chainBoostVal, realTargetParts, true);
                    break;
                case "DEF_UP_FIXED":
                    executeAttrChangeFixed(skillRole, cardLevel, chain, chainBoostVal, realTargetParts, true);
                    break;
                case "HEAL_FIXED":
                    attrVal = part.getCurrentAttr(EnumAttribute.getIndexById(skillRole[SKILL_ROLE_PARAM5]));
                    val = Long.parseLong(skillRole[SKILL_ROLE_PARAM1]) + Long.parseLong(skillRole[SKILL_ROLE_PARAM2]) * cardLevel / 1000;
                    val += Long.parseLong(skillRole[SKILL_ROLE_PARAM3]) * attrVal / 1000;
                    val = val * (100 + chainBoostVal * chain) / 100;
                    sb = new StringBuilder();
                    sb.append(getTargetName(realTargetParts)).append("回复").append(val).append("点HP。\n");
                    txtBattleInfo.append(sb.toString());
                    sb = new StringBuilder();
                    for (PartInfo targetPart : realTargetParts) {
                        if (!computeHealing(targetPart, val)) {
                            sb.append(targetPart.getName()).append("，");
                        }
                    }
                    if (sb.length() > 0) {
                        sb.deleteCharAt(sb.length() - 1);
                        sb.append("的治疗被转化为伤害。\n");
                        txtBattleInfo.append(sb.toString());
                    }
                    break;
                case "ATK_BREAK_FIXED":
                    executeAttrChangeFixed(skillRole, cardLevel, chain, chainBoostVal, realTargetParts, false);
                    break;
                case "GUARD_BREAK_FIXED":
                    executeAttrChangeFixed(skillRole, cardLevel, chain, chainBoostVal, realTargetParts, false);
                    break;
                case "REGENERATE_FIXED":
                    attrVal = part.getCurrentAttr(EnumAttribute.getIndexById(skillRole[SKILL_ROLE_PARAM6]));
                    val = Long.parseLong(skillRole[SKILL_ROLE_PARAM2]) + Long.parseLong(skillRole[SKILL_ROLE_PARAM3]) * cardLevel / 1000;
                    val += Long.parseLong(skillRole[SKILL_ROLE_PARAM4]) * attrVal / 1000;
                    val = val * (100 + chainBoostVal * chain) / 100;
                    buff = new BuffInfo(Integer.parseInt(skillRole[SKILL_ROLE_PARAM1]), turn, "REGENERATE", new Integer[]{val.intValue()}, "HEAL", true);
                    setBuffToParts(buff, realTargetParts);
                    break;
                case "ATK_UP_BY_SELF_PARAM":
                    executeAttrChangeByParam(skillRole, part, cardLevel, chain, chainBoostVal, realTargetParts, true);
                    break;
                case "DEF_UP_BY_SELF_PARAM":
                    executeAttrChangeByParam(skillRole, part, cardLevel, chain, chainBoostVal, realTargetParts, true);
                    break;
                case "HEAL_BY_SELF_PARAM":
                    val = Long.parseLong(skillRole[SKILL_ROLE_PARAM2]) * part.getCurrentAttr(EnumAttribute.getIndexById(skillRole[SKILL_ROLE_PARAM1])) / 1000;
                    sb = new StringBuilder();
                    sb.append(getTargetName(realTargetParts)).append("回复").append(val).append("点HP。\n");
                    txtBattleInfo.append(sb.toString());
                    sb = new StringBuilder();
                    for (PartInfo targetPart : realTargetParts) {
                        if (!computeHealing(targetPart, val)) {
                            sb.append(targetPart.getName()).append("，");
                        }
//                        Integer[] currentAttr = targetPart.getCurrentAttr();
//                        currentAttr[EnumAttribute.getIndexById("HP")] += val.intValue();
//                        if (currentAttr[EnumAttribute.getIndexById("HP")] > currentAttr[EnumAttribute.getIndexById("MAX_HP")]) {
//                            currentAttr[EnumAttribute.getIndexById("HP")] = currentAttr[EnumAttribute.getIndexById("MAX_HP")];
//                        }
                    }
                    if (sb.length() > 0) {
                        sb.deleteCharAt(sb.length() - 1);
                        sb.append("的治疗被转化为伤害。\n");
                        txtBattleInfo.append(sb.toString());
                    }
                    break;
                case "ATK_BREAK_BY_SELF_PARAM":
                    executeAttrChangeByParam(skillRole, part, cardLevel, chain, chainBoostVal, realTargetParts, false);
                    break;
                case "GUARD_BREAK_BY_SELF_PARAM":
                    executeAttrChangeByParam(skillRole, part, cardLevel, chain, chainBoostVal, realTargetParts, false);
                    break;
                case "CRITICAL_UP":
                    val = Long.parseLong(skillRole[SKILL_ROLE_PARAM2]);
                    buff = new BuffInfo(Integer.parseInt(skillRole[SKILL_ROLE_PARAM1]), turn, "ATTR_CHANGE", new Integer[]{val.intValue(), EnumAttribute.getIndexById("CRIT")}, skillRole[SKILL_ROLE_FUNCTION_COL], true);
                    setBuffToParts(buff, realTargetParts);
                    break;
                case "HEAL_BY_TARGET_MAXHP":
                    sb = new StringBuilder();
                    for (PartInfo targetPart : realTargetParts) {
                        val = Long.parseLong(skillRole[SKILL_ROLE_PARAM1]) * targetPart.getCurrentAttr(EnumAttribute.getIndexById("MAX_HP")) / 1000;
                        if (!computeHealing(targetPart, val)) {
                            sb.append(targetPart.getName()).append("，");
                        }
                    }
                    if (sb.length() > 0) {
                        sb.deleteCharAt(sb.length() - 1);
                        sb.append("的治疗被转化为伤害。\n");
                        txtBattleInfo.append(sb.toString());
                    }
                    break;
                case "BURN":    // Damage caused by weakness will be computed during damage phase.
                    executeSkillDot(skillRole, cardLevel, part, chainBoostVal, chain, realTargetParts);
                    break;
                case "FREEZE":
                    executeSkillDot(skillRole, cardLevel, part, chainBoostVal, chain, realTargetParts);
                    break;
                case "BLEED":
                    executeSkillDot(skillRole, cardLevel, part, chainBoostVal, chain, realTargetParts);
                    break;
                case "POISON":
                    executeSkillDot(skillRole, cardLevel, part, chainBoostVal, chain, realTargetParts);
                    break;
                case "ELECTRIC":
                    executeSkillDot(skillRole, cardLevel, part, chainBoostVal, chain, realTargetParts);
                    break;
                case "WEAKNESS":
                    val = Long.parseLong(skillRole[SKILL_ROLE_PARAM2]) / 10;   // Change ‰ to %.
                    buff = new BuffInfo(Integer.parseInt(skillRole[SKILL_ROLE_PARAM1]), turn, "WEAKNESS", new Integer[]{val.intValue()}, skillRole[SKILL_ROLE_FUNCTION_COL], false);
                    setBuffToParts(buff, realTargetParts);
                    break;
                case "CARD_TRAP_DAMAGE":
                    Boolean noEffect = true;
                    Integer minCardNum = Integer.parseInt(skillRole[SKILL_ROLE_PARAM2]);
                    Integer maxCardNum = Integer.parseInt(skillRole[SKILL_ROLE_PARAM3]);
                    val = Long.parseLong(skillRole[SKILL_ROLE_PARAM4]);
                    for (PartInfo targetPart : realTargetParts) {
                        List<Integer> availPos = new ArrayList<>();
                        ArthurInfo arthur = (ArthurInfo) targetPart;
                        for (int i = 0; i < arthur.getHandCards().length; i++) {
                            if (arthur.getHandCards()[i] != null && arthur.getHandCards()[i].getIsTrapped() == 0 && !arthur.getHandCards()[i].isPlayed()) {
                                availPos.add(i);
                            }
                        }
                        Integer[] applyPos = getRandomBuffApplyPositions(availPos, minCardNum, maxCardNum);
                        Integer[] vals = new Integer[6];
                        System.arraycopy(applyPos, 0, vals, 0, applyPos.length);
                        vals[5] = val.intValue();
                        buff = new BuffInfo(Integer.parseInt(skillRole[SKILL_ROLE_PARAM1]), turn, "CARD_TRAP_DAMAGE", vals, skillRole[SKILL_ROLE_FUNCTION_COL], false);
                        ArrayList<PartInfo> newList = new ArrayList<>();
                        newList.add(targetPart);
                        if (setBuffToParts(buff, newList)) {
                            noEffect = false;
                        }
                    }
                    sb = new StringBuilder();
                    sb.append(Integer.parseInt(skillRole[SKILL_ROLE_PARAM1])).append("回合间，").append(getTargetName(realTargetParts)).
                            append("的卡牌陷阱").append(minCardNum);
                    if (!minCardNum.equals(maxCardNum)) {
                        sb.append("～").append(maxCardNum);
                    }
                    sb.append("张。");
                    if (noEffect) {
                        sb.append("（未生效）");
                    }
                    sb.append("\n");
                    txtBattleInfo.append(sb.toString());
                    break;
                case "CARD_SEAL":
                    noEffect = true;
                    Integer minRound = Integer.parseInt(skillRole[SKILL_ROLE_PARAM1]);
                    Integer maxRound = Integer.parseInt(skillRole[SKILL_ROLE_PARAM2]);
                    minCardNum = Integer.parseInt(skillRole[SKILL_ROLE_PARAM3]);
                    maxCardNum = Integer.parseInt(skillRole[SKILL_ROLE_PARAM4]);
                    Long round = Math.round(Math.random() * (maxRound - minRound + 1) - 0.5) + minRound;
                    String categoryFilter = skillRole[SKILL_ROLE_PARAM5];
                    String typeFilter = skillRole[SKILL_ROLE_PARAM6];
                    String minCost = skillRole[SKILL_ROLE_PARAM7];
                    String maxCost = skillRole[SKILL_ROLE_PARAM8];
                    Integer filterCondition = Integer.parseInt(skillRole[SKILL_ROLE_PARAM9]);
                    for (PartInfo targetPart : realTargetParts) {
                        List<Integer> availPos = new ArrayList<>();
                        ArthurInfo arthur = (ArthurInfo) targetPart;
                        for (int i = 0; i < arthur.getHandCards().length; i++) {
                            if (arthur.getHandCards()[i] == null || arthur.getHandCards()[i].getIsSealed() > 0 || arthur.getHandCards()[i].isPlayed()) {
                                continue;
                            }
                            String[] arthurSkillBase = skillMap.get(arthur.getHandCards()[i].getSkillId()).get(0);
                            Boolean passFilter = true;
                            if (!categoryFilter.equals("ALL") && !arthurSkillBase[9].equals(categoryFilter)) {
                                passFilter = false;
                            }
                            if (!typeFilter.equals("ALL") && !arthurSkillBase[10].contains(typeFilter)) {
                                passFilter = false;
                            }
                            if (!minCost.equals("ALL")
                                    && !(Integer.parseInt(minCost) <= Integer.parseInt(arthurSkillBase[13]) && Integer.parseInt(maxCost) >= Integer.parseInt(arthurSkillBase[13]))) {
                                passFilter = false;
                            }
                            if (filterCondition == 0) {
                                passFilter = !passFilter;
                            }
                            if (passFilter) {
                                availPos.add(i);
                            }
                        }
                        Integer[] applyPos = getRandomBuffApplyPositions(availPos, minCardNum, maxCardNum);
                        buff = new BuffInfo(round.intValue(), turn, "CARD_SEAL", applyPos, skillRole[SKILL_ROLE_FUNCTION_COL], false);
                        ArrayList<PartInfo> newList = new ArrayList<>();
                        newList.add(targetPart);
                        if (setBuffToParts(buff, newList)) {
                            noEffect = false;
                        }
                    }
                    sb = new StringBuilder();
                    sb.append(round.intValue()).append("回合间，封印").append(getTargetName(targetParts)).
                            append("的");
                    if (filterCondition == 0) {
                        sb.append("非");
                    }
                    if (!minCost.equals("ALL")) {
                        sb.append(minCost);
                        if (!minCost.equals(maxCost)) {
                            sb.append("～").append(maxCost);
                        }
                        sb.append("C");
                    }
                    if (!typeFilter.equals("ALL")) {
                        sb.append(EnumType.getNameById(typeFilter)).append("属性");
                    }
                    if (!categoryFilter.equals("ALL")) {
                        sb.append(CATEGORY_MAP.get(categoryFilter));
                    }
                    sb.append("卡牌").append(minCardNum);
                    if (!minCardNum.equals(maxCardNum)) {
                        sb.append("～").append(maxCardNum);
                    }
                    sb.append("张。");
                    if (noEffect) {
                        sb.append("（未生效）");
                    }
                    sb.append("\n");
                    txtBattleInfo.append(sb.toString());
                    break;
                case "DARKNESS_RANDOM":
                    for (PartInfo targetPart : realTargetParts) {
                        List<Integer> availPos = new ArrayList<>();
                        Boolean[] darknessPos = targetPart.getDarknessPos();
                        for (int i = 0; i < darknessPos.length; i++) {
                            if (darknessPos[i] == false) {
                                availPos.add(i);
                            }
                        }
                        minCardNum = Integer.parseInt(skillRole[SKILL_ROLE_PARAM2]);
                        maxCardNum = Integer.parseInt(skillRole[SKILL_ROLE_PARAM3]);
                        Integer[] darkPos = getRandomBuffApplyPositions(availPos, minCardNum, maxCardNum);
                        buff = new BuffInfo(Integer.parseInt(skillRole[SKILL_ROLE_PARAM1]), turn, "DARKNESS", darkPos, "DARKNESS", false);
                        ArrayList<PartInfo> newList = new ArrayList<>();
                        newList.add(targetPart);
                        setBuffToParts(buff, newList);
                    }
                    break;
                case "DARKNESS_APPOINT":
                    buff = new BuffInfo(Integer.parseInt(skillRole[SKILL_ROLE_PARAM1]), turn, "DARKNESS",
                            new Integer[]{Integer.parseInt(skillRole[SKILL_ROLE_PARAM2]), Integer.parseInt(skillRole[SKILL_ROLE_PARAM2]), Integer.parseInt(skillRole[SKILL_ROLE_PARAM2]),
                                Integer.parseInt(skillRole[SKILL_ROLE_PARAM2]), Integer.parseInt(skillRole[SKILL_ROLE_PARAM2])}, "DARKNESS", false);
                    setBuffToParts(buff, realTargetParts);
                    break;
                case "HEAL_REVERSE":
                    buff = new BuffInfo(Integer.parseInt(skillRole[SKILL_ROLE_PARAM1]), turn, "HEAL_REVERSE", null, skillRole[SKILL_ROLE_FUNCTION_COL], false);
                    setBuffToParts(buff, realTargetParts);
                    break;
                case "BUFF_RELEASE":
                    buff = new BuffInfo(0, turn, "RELEASE", null, skillRole[SKILL_ROLE_FUNCTION_COL], true);
                    setBuffToParts(buff, realTargetParts);
                    break;
                case "BUFF_RELEASE_ONE":
                    Integer[] values;
                    Integer buff1 = EnumBuff.getIndexById(skillRole[SKILL_ROLE_PARAM3]);
                    Integer buff2 = EnumBuff.getIndexById(skillRole[SKILL_ROLE_PARAM4]);
                    if (buff2.equals(buff1) || buff2 == 0) {
                        values = new Integer[]{buff1};
                    } else {
                        values = new Integer[]{buff1, buff2};
                    }
                    buff = new BuffInfo(0, turn, "RELEASE", values, skillRole[SKILL_ROLE_FUNCTION_COL], true);
                    setBuffToParts(buff, realTargetParts);
                    break;
                case "DEBUFF_RELEASE":
                    buff = new BuffInfo(0, turn, "RELEASE", null, skillRole[SKILL_ROLE_FUNCTION_COL], false);
                    setBuffToParts(buff, realTargetParts);
                    break;
                case "DEBUFF_RELEASE_ONE":
                    buff1 = EnumBuff.getIndexById(skillRole[SKILL_ROLE_PARAM3]);
                    buff2 = EnumBuff.getIndexById(skillRole[SKILL_ROLE_PARAM4]);
                    if (buff2.equals(buff1) || buff2 == 0) {
                        values = new Integer[]{buff1};
                    } else {
                        values = new Integer[]{buff1, buff2};
                    }
                    buff = new BuffInfo(0, turn, "RELEASE", values, skillRole[SKILL_ROLE_FUNCTION_COL], false);
                    setBuffToParts(buff, realTargetParts);
                    break;
                case "CARD_SEAL_REGIST":
                    val = Long.parseLong(skillRole[SKILL_ROLE_PARAM2]);
                    buff = new BuffInfo(Integer.parseInt(skillRole[SKILL_ROLE_PARAM1]), turn, "REGIST", new Integer[]{val.intValue()}, skillRole[SKILL_ROLE_FUNCTION_COL], true);
                    setBuffToParts(buff, realTargetParts);
                    break;
                case "DARKNESS_REGIST":
                    val = Long.parseLong(skillRole[SKILL_ROLE_PARAM2]);
                    buff = new BuffInfo(Integer.parseInt(skillRole[SKILL_ROLE_PARAM1]), turn, "REGIST", new Integer[]{val.intValue()}, skillRole[SKILL_ROLE_FUNCTION_COL], true);
                    setBuffToParts(buff, realTargetParts);
                    break;
                case "COVERING":
                    val = Long.parseLong(skillRole[SKILL_ROLE_PARAM2]) / 10;
                    buff = new BuffInfo(Integer.parseInt(skillRole[SKILL_ROLE_PARAM1]), turn, "COVERING", new Integer[]{val.intValue()}, skillRole[SKILL_ROLE_FUNCTION_COL], true);
                    setBuffToParts(buff, realTargetParts);
                    break;
                case "STAN":
                    val = Long.parseLong(skillRole[SKILL_ROLE_PARAM2]);
                    buff = new BuffInfo(Integer.parseInt(skillRole[SKILL_ROLE_PARAM1]), turn, "STAN", new Integer[]{val.intValue()}, skillRole[SKILL_ROLE_FUNCTION_COL], false);
                    setBuffToParts(buff, realTargetParts);
                    break;
                case "ATTR_SEE":
                    buff = new BuffInfo(Integer.parseInt(skillRole[SKILL_ROLE_PARAM1]), turn, "TYPE_HIDE", null, skillRole[SKILL_ROLE_FUNCTION_COL], false);
                    setBuffToParts(buff, realTargetParts);
                    break;
                case "ATTR_HIDE":
                    buff = new BuffInfo(Integer.parseInt(skillRole[SKILL_ROLE_PARAM1]), turn, "TYPE_HIDE", null, skillRole[SKILL_ROLE_FUNCTION_COL], true);
                    setBuffToParts(buff, realTargetParts);
                    break;
                case "REWRITE":
                    buff = new BuffInfo(Integer.parseInt(skillRole[SKILL_ROLE_PARAM1]), turn, "REWRITE", new Integer[]{EnumType.getIndexById(skillRole[SKILL_ROLE_PARAM2])}, skillRole[SKILL_ROLE_FUNCTION_COL], true);
                    setBuffToParts(buff, realTargetParts);
                    break;
                case "DEAL_BONUS":  // Default 1 round
                    val = Long.parseLong(skillRole[SKILL_ROLE_PARAM1]);
                    buff = new BuffInfo(1, turn, "DEAL", new Integer[]{val.intValue()}, skillRole[SKILL_ROLE_FUNCTION_COL], true);
                    setBuffToParts(buff, realTargetParts);
                    break;
                case "DEAL_PENALTY":
                    val = Long.parseLong(skillRole[SKILL_ROLE_PARAM1]) * (-1);
                    buff = new BuffInfo(1, turn, "DEAL", new Integer[]{val.intValue()}, skillRole[SKILL_ROLE_FUNCTION_COL], false);
                    setBuffToParts(buff, realTargetParts);
                    break;
                case "DEAL_PENALTY_TURN_APPOINT":
                    val = Long.parseLong(skillRole[SKILL_ROLE_PARAM2]) * (-1);
                    buff = new BuffInfo(Integer.parseInt(skillRole[SKILL_ROLE_PARAM1]), turn, "DEAL", new Integer[]{val.intValue()}, "DEAL_PENALTY", false);
                    setBuffToParts(buff, realTargetParts);
                    break;
                case "ENEMY_AI_TRIGGER_FLAG_SET":
                    enemyTriggerAiFlag.put(skillRole[SKILL_ROLE_PARAM1], Integer.parseInt(skillRole[SKILL_ROLE_PARAM2]));
                    break;
                case "ATTACK_BARRIER":
                    buff = new BuffInfo(Integer.parseInt(skillRole[SKILL_ROLE_PARAM1]), turn, "ATTACK_BARRIER",
                            new Integer[]{Integer.parseInt(skillRole[SKILL_ROLE_PARAM2]), Integer.parseInt(skillRole[SKILL_ROLE_PARAM4]), EnumPhysicsMagic.getIndexById(skillRole[SKILL_ROLE_PARAM5])}, skillRole[SKILL_ROLE_FUNCTION_COL], false);
                    setBuffToParts(buff, realTargetParts);
                    break;
                case "DESTRUCT":
                    for (PartInfo targetPart : realTargetParts) {
                        //Integer[] currentAttr = targetPart.getCurrentAttr();
                        val = Long.parseLong(skillRole[SKILL_ROLE_PARAM1]) * targetPart.getCurrentAttr(EnumAttribute.getIndexById("HP")) / 100;
                        if (!skillRole[SKILL_ROLE_PARAM1].equals("100") && val.intValue() == targetPart.getCurrentAttr(EnumAttribute.getIndexById("HP"))) {
                            val = targetPart.getCurrentAttr(EnumAttribute.getIndexById("HP")).longValue() - 1;
                        }
                        targetPart.changeCurrentAttr(-val.intValue(), EnumAttribute.getIndexById("HP"));
                        if (targetPart.getCurrentAttr(EnumAttribute.getIndexById("HP")) == 0) {
                            targetPart.setDead(true);
                            targetPart.setDeadCount(targetPart.getDeadCount() + 1);
                            clearBuffsForDead(targetPart);
                        }
                        sb = new StringBuilder();
                        if (val == 0) {
                            sb.append(getTargetName(realTargetParts)).append("破坏！\n");
                        } else {
                            sb.append(getTargetName(realTargetParts)).append("破坏，损失").append(skillRole[SKILL_ROLE_PARAM1]).append("％HP。\n");
                        }
                        txtBattleInfo.append(sb.toString());
                    }
                    break;
                case "COST_BLOCK":
                    buff = new BuffInfo(Integer.parseInt(skillRole[SKILL_ROLE_PARAM1]), turn, "COST_BLOCK", new Integer[]{Integer.parseInt(skillRole[SKILL_ROLE_PARAM2])}, "COST_BLOCK", false);
                    setBuffToParts(buff, realTargetParts);
                    break;
                case "ENCHANT":
                    val = Long.parseLong(skillRole[SKILL_ROLE_PARAM2]) + Long.parseLong(skillRole[SKILL_ROLE_PARAM5]) * cardLevel;
                    val = val * (100 + chainBoostVal * chain) / 100;
                    buff = new BuffInfo(Integer.parseInt(skillRole[SKILL_ROLE_PARAM1]), turn, "ENCHANT", new Integer[]{val.intValue(), EnumType.getIndexById(skillRole[SKILL_ROLE_PARAM6])}, "ENCHANT", true);
                    setBuffToParts(buff, realTargetParts);
                    break;
                case "DOT_VALUE_UP":    // NOT TESTED YET.
                    buff = new BuffInfo(Integer.parseInt(skillRole[SKILL_ROLE_PARAM1]), turn, "DOT_VALUE_UP", new Integer[]{Integer.parseInt(skillRole[SKILL_ROLE_PARAM2]), EnumBuff.getIndexById(skillRole[SKILL_ROLE_PARAM6])}, "DOT_VALUE_UP", true);
                    setBuffToParts(buff, realTargetParts);
                    break;
                default:
                    txtBattleInfo.append("Unrecognized: " + skillRole[SKILL_ROLE_FUNCTION_COL] + "\n");
                    break;
            }
        }
    }

    private void applyDamageToParent(PartInfo targetPart, Long damage) {
        StringBuilder sb;
        if (!targetPart.getParent().equals(-1) && !enemyList.get(targetPart.getParent()).isDead()) {
            PartInfo parentEnemy = enemyList.get(targetPart.getParent());
            parentEnemy.changeCurrentAttr(-damage.intValue(), EnumAttribute.getIndexById("HP"));
            if (parentEnemy.getCurrentAttr(EnumAttribute.getIndexById("HP")) < 0) {
                parentEnemy.changeCurrentAttr(-parentEnemy.getCurrentAttr(EnumAttribute.getIndexById("HP")), EnumAttribute.getIndexById("HP"));
                parentEnemy.setDead(true);
                parentEnemy.setDeadCount(parentEnemy.getDeadCount() + 1);
                clearBuffsForDead(parentEnemy);
                sb = new StringBuilder();
                sb.append(parentEnemy.getName()).append("被击破！\n");
                txtBattleInfo.append(sb.toString());
            }
        }
    }

    /**
     * @return - true if heal, false if damage.
     */
    private boolean computeHealing(PartInfo targetPart, Long val) {
        //Integer[] currentAttr = targetPart.getCurrentAttr();
        if (targetPart.getBuffs().containsKey("HEAL_REVERSE") && !targetPart.getBuffs().get("HEAL_REVERSE").isEmpty()) {
            Integer damage = val.intValue();
            damage = Math.min(damage, targetPart.getCurrentAttr(EnumAttribute.getIndexById("HP")) - 1);
            targetPart.changeCurrentAttr(-damage, EnumAttribute.getIndexById("HP"));
            targetPart.setDamageTaken(targetPart.getDamageTaken() + damage);
            targetPart.setDamageTakenNowTurn(targetPart.getDamageTakenNowTurn() + damage);
            return false;
        } else {
            targetPart.changeCurrentAttr(Math.min(val.intValue(),
                    targetPart.getCurrentAttr(EnumAttribute.getIndexById("MAX_HP")) - targetPart.getCurrentAttr(EnumAttribute.getIndexById("HP"))),
                    EnumAttribute.getIndexById("HP"));
            targetPart.setHealTakenNowTurn(targetPart.getHealTakenNowTurn() + val.intValue());
            return true;
        }
    }

    private Integer[] getRandomBuffApplyPositions(List<Integer> availPos, int minCardNum, int maxCardNum) {
        Integer[] applyPos = new Integer[]{0, 0, 0, 0, 0};
        Long val;
        long n = availPos.size();
        Integer temp;
        for (int i = 0; i < n; i++) {
            Integer index = ((Long) Math.round(Math.random() * (n - i) - 0.5 + i)).intValue();
            if (index != i) {
                temp = availPos.get(i);
                availPos.set(i, availPos.get(index));
                availPos.set(index, temp);
            }
        }
        val = Math.round(Math.random() * (maxCardNum - minCardNum + 1) - 0.5) + minCardNum;
        for (int i = 0; i < val; i++) {
            if (availPos.size() > i) {
                applyPos[availPos.get(i)] = 1;
            }
        }
        return applyPos;
    }

    private void executeAttrChangeByParam(String[] skillRole, PartInfo part, Integer cardLevel, Integer chain, Long chainBoostVal, List<PartInfo> realTargetParts, boolean isBuff) {
        Long val;
        BuffInfo buff;
        Long spRate = 0L, spCardLevelRate = 0L;
        if (skillRole.length > 22 && skillRole[SKILL_ROLE_PARAM5].matches("[\\d]+")) {
            spRate = Long.parseLong(skillRole[SKILL_ROLE_PARAM5]);
        }
        if (skillRole.length > 23 && skillRole[SKILL_ROLE_PARAM6].matches("[\\d]+")) {
            spCardLevelRate = Long.parseLong(skillRole[SKILL_ROLE_PARAM6]);
        }
        Integer attrVal = part.getCurrentAttr(EnumAttribute.getIndexById(skillRole[SKILL_ROLE_PARAM3]));
        val = (Long.parseLong(skillRole[SKILL_ROLE_PARAM4]) + spRate) * attrVal / 1000;
        val += spCardLevelRate * cardLevel;
        log.debug(spCardLevelRate);
        log.debug(cardLevel);
        val += chain * chainBoostVal;
        if (!isBuff) {
            val = -val;
        }
        String releaseName = skillRole[SKILL_ROLE_FUNCTION_COL].substring(0, skillRole[SKILL_ROLE_FUNCTION_COL].lastIndexOf("SELF")) + skillRole[SKILL_ROLE_PARAM2];
        buff = new BuffInfo(Integer.parseInt(skillRole[SKILL_ROLE_PARAM1]), turn, "ATTR_CHANGE", new Integer[]{val.intValue(),
            EnumAttribute.getIndexById(skillRole[SKILL_ROLE_PARAM2])}, releaseName, isBuff);
        setBuffToParts(buff, realTargetParts);
    }

    private void executeAttrChangeFixed(String[] skillRole, Integer cardLevel, Integer chain, Long chainBoostVal, List<PartInfo> realTargetParts, boolean isBuff) {
        Long val;
        BuffInfo buff;
        val = Long.parseLong(skillRole[SKILL_ROLE_PARAM3]) * (Long.parseLong(skillRole[SKILL_ROLE_PARAM4]) + Long.parseLong(skillRole[SKILL_ROLE_PARAM5]) * cardLevel) / 1000;
        val += chain * chainBoostVal;  // 0 = 1Chain, 3 = 4Chain.
        if (!isBuff) {
            val = -val;
        }
        String releaseName = skillRole[SKILL_ROLE_FUNCTION_COL].substring(0, skillRole[SKILL_ROLE_FUNCTION_COL].lastIndexOf("_")) + "_BY_" + skillRole[SKILL_ROLE_PARAM2];
        buff = new BuffInfo(Integer.parseInt(skillRole[SKILL_ROLE_PARAM1]), turn, "ATTR_CHANGE", new Integer[]{val.intValue(),
            EnumAttribute.getIndexById(skillRole[SKILL_ROLE_PARAM2])}, releaseName, isBuff);
        setBuffToParts(buff, realTargetParts);
    }

    private void executeSkillDot(String[] skillRole, Integer cardLevel, PartInfo part, Long chainBoostVal, Integer chain, List<PartInfo> realTargetParts) {
        Long val;
        BuffInfo buff;
        Integer attrVal = part.getCurrentAttr(EnumAttribute.getIndexById(skillRole[SKILL_ROLE_PARAM8]));
        val = Long.parseLong(skillRole[SKILL_ROLE_PARAM3]) + Long.parseLong(skillRole[SKILL_ROLE_PARAM4]) + Long.parseLong(skillRole[SKILL_ROLE_PARAM5]) * cardLevel / 1000;
        val += Long.parseLong(skillRole[SKILL_ROLE_PARAM6]) * attrVal / 1000;
        val = val * (100 + chainBoostVal * chain) / 100;
        String atkType = EnumType.getIdByDotId(skillRole[SKILL_ROLE_FUNCTION_COL]);
        Integer index = EnumType.getIndexById(atkType);
        for (PartInfo targetPart : realTargetParts) {
            if (targetPart.isArthur()) {
                buff = new BuffInfo(Integer.parseInt(skillRole[SKILL_ROLE_PARAM1]), turn, "DOT", new Integer[]{val.intValue(), index}, skillRole[SKILL_ROLE_FUNCTION_COL], false);
            } else {
                buff = new BuffInfo(Integer.parseInt(skillRole[SKILL_ROLE_PARAM1]), turn, "DOT", new Integer[]{val.intValue(), index}, skillRole[SKILL_ROLE_FUNCTION_COL], false);
            }
            ArrayList<PartInfo> newList = new ArrayList<>();
            newList.add(targetPart);
            setBuffToParts(buff, newList);
        }
    }

    /**
     * @return - True if the skill take effect, false otherwise.
     */
    private boolean setBuffToParts(BuffInfo buff, List<PartInfo> targetParts) {
        //List<BuffInfo> buffs;
        boolean ignore = false;
        boolean noEffect = true;
        for (PartInfo part : targetParts) {
            //buffs = part.getBuffs();
            if (!part.getBuffs().containsKey(buff.getBuffName())) {
                part.getBuffs().put(buff.getBuffName(), new ArrayList<>());
            }
            switch (buff.getType()) {
                case "ATTR_CHANGE":
                    part.changeCurrentAttr(buff.getValue()[0], buff.getValue()[1]);
                    if (buff.getValue()[1].equals(EnumAttribute.MAX_HP.getIndex())) {
                        part.changeCurrentAttr(buff.getValue()[0], EnumAttribute.HP.getIndex());
                    }
                    part.getBuffs().get(buff.getBuffName()).add(buff);
                    break;
                case "REGENERATE":
                    ignore = false;
                    if (!part.getBuffs().get(buff.getBuffName()).isEmpty()) {
                        BuffInfo reg = part.getBuffs().get(buff.getBuffName()).get(0);
                        log.debug("Turn set: " + reg.getTurnSet() + " | Turn left: " + reg.getTurnLeft());
                        if (reg.getValue()[0] >= buff.getValue()[0]
                                && (reg.getTurnSet() + reg.getTurnLeft() - 1) > turn) {
                            ignore = true;
                        }
                    }
                    if (!ignore) {
                        noEffect = false;
                        part.getBuffs().get(buff.getBuffName()).clear();
                        part.getBuffs().get(buff.getBuffName()).add(buff);
                    }
                    break;
                case "DOT":
                    ignore = false;
                    if (!part.getBuffs().get(buff.getBuffName()).isEmpty()) {
                        ignore = true;      // DOT cannot overwrite.
                        break;
                    }
                    if (part.getBuffs().containsKey(buff.getBuffName() + "_RESIST")
                            && !part.getBuffs().get(buff.getBuffName() + "_RESIST").isEmpty()) {
                        ignore = true;      // DOT resistance
                        break;
                    }
                    if (!ignore) {
                        part.getBuffs().get(buff.getBuffName()).add(buff);
                    }
                    break;
                case "WEAKNESS":    // NOTICE: only ONE PART is allowed in each side to have this debuff.
                    StringBuilder sb = new StringBuilder();
                    if (part.isArthur()) {
                        for (ArthurInfo arthur : arthurList) {
                            if (arthur.getBuffs().get(buff.getBuffName()) != null
                                    && (!arthur.getBuffs().get(buff.getBuffName()).isEmpty())) {
                                sb.append(arthur.getName()).append("的标记状态被取消了。\n");
                                txtBattleInfo.append(sb.toString());
                                arthur.getBuffs().get(buff.getBuffName()).clear();
                                break;
                            }
                        }
                    } else {
                        for (EnemyInfo enemy : enemyList) {
                            if (enemy.getBuffs().get(buff.getBuffName()) != null
                                    && (!enemy.getBuffs().get(buff.getBuffName()).isEmpty())) {
                                sb.append(enemy.getName()).append("的标记状态被取消了。\n");
                                txtBattleInfo.append(sb.toString());
                                enemy.getBuffs().get(buff.getBuffName()).clear();
                                break;
                            }
                        }
                    }
                    part.getBuffs().get(buff.getBuffName()).add(buff);
                    break;
                case "HEAL_REVERSE":
                    ignore = false;
                    if (!part.getBuffs().get(buff.getBuffName()).isEmpty()) {
                        ignore = true;      // HEAL_REVERSE cannot overwrite (?).
                        break;
                    }
                    if (!ignore) {
                        noEffect = false;
                        part.getBuffs().get(buff.getBuffName()).add(buff);
                    }
                    break;
                case "REGIST":      // Accumulate.(?)
                    part.getBuffs().get(buff.getBuffName()).add(buff);
                    break;
                case "DEAL":        // Replace - More card qty ones will replace less ones, and assume more turn would replace less turn ones.
                    ignore = false;
                    if (!part.getBuffs().get(buff.getBuffName()).isEmpty()
                            && part.getBuffs().get(buff.getBuffName()).get(0).getValue()[0] >= buff.getValue()[0]
                            && part.getBuffs().get(buff.getBuffName()).get(0).getTurnLeft() >= buff.getTurnLeft()) {
                        ignore = true;
                    }
                    if (!ignore) {
                        noEffect = false;
                        part.getBuffs().get(buff.getBuffName()).clear();
                        part.getBuffs().get(buff.getBuffName()).add(buff);
                    }
                    break;
                case "COVERING":    // Replace without any condition.
                    if (!part.getBuffs().get(buff.getBuffName()).isEmpty()) {
                        part.getBuffs().get(buff.getBuffName()).clear();
                    }
                    part.getBuffs().get(buff.getBuffName()).add(buff);
                    part.changeCurrentAttr(-part.getCurrentAttr(EnumAttribute.getIndexById("DDUC")), EnumAttribute.getIndexById("DDUC"));
                    part.changeCurrentAttr(buff.getValue()[0], EnumAttribute.getIndexById("DDUC"));
                    //part.getCurrentAttr()[EnumAttribute.getIndexById("DDUC")] = buff.getValue()[0];
                    break;
                case "STAN":        // Replace if succeed.
                    Long prob = Math.round(Math.random() * 100 + 0.5);
                    if (prob > buff.getValue()[0]) {
                        sb = new StringBuilder();
                        sb.append("未能打断").append(part.getName()).append("的行动。\n");
                        txtBattleInfo.append(sb.toString());
                    } else {
                        part.getBuffs().get(buff.getBuffName()).clear();
                        part.getBuffs().get(buff.getBuffName()).add(buff);
                        sb = new StringBuilder();
                        if (buff.getTurnLeft() > 1) {
                            sb.append(buff.getTurnLeft()).append("回合间，");
                        }
                        sb.append(part.getName()).append("的行动停止了。\n");
                        txtBattleInfo.append(sb.toString());
                    }
                    break;
                case "TYPE_HIDE":   // Replace without any condition. NOTICE: ATTR_SEE is stronger than ATTR_HIDE.
                    part.getBuffs().get(buff.getBuffName()).clear();
                    part.getBuffs().get(buff.getBuffName()).add(buff);
                    break;
                case "REWRITE":
                    part.getBuffs().get(buff.getBuffName()).clear();
                    part.getBuffs().get(buff.getBuffName()).add(buff);
                    part.setType(EnumType.getIdByIndex(buff.getValue()[0]));
                    break;
                case "ATTACK_BARRIER":  // Replace without any condition.
                    if (!part.getBuffs().get(buff.getBuffName()).isEmpty()) {
                        part.getBuffs().get(buff.getBuffName()).clear();
                        sb = new StringBuilder();
                        sb.append(part.getName()).append("现有的免伤盾被取消了。\n");
                        txtBattleInfo.append(sb.toString());
                    }
                    part.getBuffs().get(buff.getBuffName()).add(buff);
                    break;
                case "DARKNESS":    // NOT Accumulate. Assume resist apply to the part, not each card.
                    ignore = false;
                    if (part.getBuffs().containsKey("DARKNESS_REGIST")
                            && !part.getBuffs().get("DARKNESS_REGIST").isEmpty()) {
                        for (BuffInfo resistBuff : part.getBuffs().get("DARKNESS_REGIST")) {
                            if (Math.round(Math.random() * 100 + 0.5) <= resistBuff.getValue()[0]) {
                                ignore = true;
                                break;
                            }
                        }
                    }
                    if (ignore) {
                        break;
                    }
                    for (int i = 0; i < buff.getValue().length; i++) {
                        if (buff.getValue()[i] == 1) {
                            if (part.getDarknessPos()[i] == false) {
                                part.getDarknessPos()[i] = true;
                                noEffect = false;
                            } else {
                                buff.getValue()[i] = 0; // Remove this darkness effect.
                            }
                        }
                    }
                    if (!noEffect) {
                        part.getBuffs().get(buff.getBuffName()).add(buff);
                    }
                    break;
                case "CARD_TRAP_DAMAGE":
                    ignore = false;
                    for (int i = 0; i < 5; i++) {
                        if (buff.getValue()[i] == 1) {
                            if (((ArthurInfo) part).getHandCards()[i].getIsTrapped() > 0) {
                                log.error("ERROR.");
                            }
                            ((ArthurInfo) part).getHandCards()[i].setIsTrapped(buff.getValue()[5]);
                            noEffect = false;
                        }
                    }
                    if (!noEffect) {
                        part.getBuffs().get(buff.getBuffName()).add(buff);
                    }
                    break;      // DO NOTHING
                case "CARD_SEAL":
                    ignore = false;
                    if (part.getBuffs().containsKey("CARD_SEAL_REGIST")
                            && !part.getBuffs().get("CARD_SEAL_REGIST").isEmpty()) {
                        for (BuffInfo resistBuff : part.getBuffs().get("CARD_SEAL_REGIST")) {
                            if (Math.round(Math.random() * 100 + 0.5) <= resistBuff.getValue()[0]) {
                                ignore = true;
                            }
                        }
                    }
                    if (ignore) {
                        break;
                    }
                    for (int i = 0; i < buff.getValue().length; i++) {
                        if (buff.getValue()[i] == 1) {
                            if (((ArthurInfo) part).getHandCards()[i].getIsSealed() > 0) {
                                log.error("ERROR.");
                            }
                            ((ArthurInfo) part).getHandCards()[i].setIsSealed(buff.getTurnLeft());
                            noEffect = false;
                        }
                    }
                    if (!noEffect) {
                        part.getBuffs().get(buff.getBuffName()).add(buff);
                    }
                    break;      // DO NOTHING
                case "RELEASE":
                    Set<String> buffNames;
                    if (buff.getValue() == null) {
                        buffNames = part.getBuffs().keySet();
                    } else {
                        buffNames = new HashSet<>();
                        for (Integer buffIndex : buff.getValue()) {
                            buffNames.add(EnumBuff.getIdByIndex(buffIndex));
                        }
                    }
                    for (String buffName : buffNames) {
                        log.info("Try to remove buff: " + buffName);
                        if (buffName.equals("DEAL_BONUS") || buffName.equals("DEAL_PENALTY")) {
                            continue;
                        }
                        if (part.getBuffs().containsKey(buffName)) {
                            List<BuffInfo> reBuffs = part.getBuffs().get(buffName);
                            for (BuffInfo reBuff : reBuffs) {
                                if (reBuff.isBuff() == buff.isBuff()) {
                                    removeBuffEffectFromPart(reBuff, part);
                                }
                            }
                            if (!reBuffs.isEmpty() && reBuffs.get(0).isBuff() == buff.isBuff()) {
                                noEffect = false;
                                reBuffs.clear();
                            }
                        }
                    }
                    break;
                case "COST_BLOCK":  // Replace.
                    if (!part.isArthur()) {
                        log.error("ERROR for COST_BLOCK.");
                        break;
                    }
                    if (!part.getBuffs().get(buff.getBuffName()).isEmpty()) {
                        part.getBuffs().get(buff.getBuffName()).clear();
                    }
                    part.getBuffs().get(buff.getBuffName()).add(buff);
                    ((ArthurInfo) part).setCostBlocked(buff.getValue()[0]);
                    break;
                case "ENCHANT":    // Replace if value is higher.
                    ignore = false;
                    if (!part.getBuffs().get(buff.getBuffName()).isEmpty()) {
                        BuffInfo exEnchant = part.getBuffs().get(buff.getBuffName()).get(0);
                        if (exEnchant.getValue()[0] >= buff.getValue()[0]) {
                            ignore = true;
                        }
                    }
                    if (!ignore) {
                        noEffect = false;
                        part.getBuffs().get(buff.getBuffName()).clear();
                        part.getBuffs().get(buff.getBuffName()).add(buff);
                    }
                    break;
                case "DOT_VALUE_UP":    // Does not add, just change target's dot.
                    String dotId = EnumBuff.getIdByIndex(buff.getValue()[1]);
                    if (part.getBuffs().containsKey(dotId) && !part.getBuffs().get(dotId).isEmpty()) {
                        BuffInfo dot = part.getBuffs().get(dotId).get(0);
                        dot.extendTurn(buff.getTurnLeft());
                        Long dotVal = dot.getValue()[0].longValue();
                        dotVal = dotVal * (100 + buff.getValue()[0]) / 100;
                        dot.getValue()[0] = dotVal.intValue();
                        noEffect = false;
                    }
                default:
                    log.error("ERROR.");
                    break;
            }
        }

        // Output text (avoid multiple output for 'ALL' case).
        StringBuilder sb;
        switch (buff.getType()) {
            case "ATTR_CHANGE":
                sb = new StringBuilder();
                sb.append(buff.getTurnLeft()).append("回合间，").append(getTargetName(targetParts)).append("的");
                String name = EnumAttribute.getNameByIndex(buff.getValue()[1]);
                if (name.equals("治疗量") && !targetParts.get(0).isArthur()) {
                    name = "支援值";
                }
                sb.append(name);
                if (buff.getValue()[0] > 0) {
                    sb.append("提升").append(buff.getValue()[0]);
                } else {
                    sb.append("降低").append(-buff.getValue()[0]);
                }
                if (buff.getValue()[1] != 8) {
                    sb.append("点。\n");
                } else {
                    sb.append("％。\n");
                }
                txtBattleInfo.append(sb.toString());
                break;
            case "REGENERATE":
                sb = new StringBuilder();
                sb.append(buff.getTurnLeft()).append("回合间，").append(getTargetName(targetParts)).
                        append("的HP每回合回复").append(buff.getValue()[0]).append("点。");
                if (noEffect) {
                    sb.append("（未生效）");
                }
                sb.append("\n");
                txtBattleInfo.append(sb.toString());
                break;
            case "DOT":
                sb = new StringBuilder();
                if (!ignore) {
                    if (targetParts.size() > 1) {
                        log.error("ERROR.");
                    }
                    Integer typeRate;
                    if (targetParts.get(0).getTypeRate()[buff.getValue()[1]].equals(100)) {
                        typeRate = EnumType.getNormalRate(EnumType.getIdByIndex(buff.getValue()[1]), targetParts.get(0).getType());
                    } else {
                        typeRate = targetParts.get(0).getTypeRate()[buff.getValue()[1]];
                    }
                    sb.append(buff.getTurnLeft() - 1).append("回合间，对").append(getTargetName(targetParts)).
                            append("每回合造成").append(buff.getValue()[0] * typeRate / 100).append("点").
                            append(EnumType.getDotNameByIndex(buff.getValue()[1])).append("伤害。\n");
                    txtBattleInfo.append(sb.toString());
                } else {
                    sb.append(EnumType.getDotNameByIndex(buff.getValue()[1])).append("效果对").append(getTargetName(targetParts)).append("无效。\n");
                    txtBattleInfo.append(sb.toString());
                }
                break;
            case "WEAKNESS":
                sb = new StringBuilder();
                sb.append(getTargetName(targetParts)).append("标记").append(buff.getTurnLeft()).
                        append("回合，提升伤害").append(buff.getValue()[0]).append("％。\n");
                txtBattleInfo.append(sb.toString());
                break;
            case "HEAL_REVERSE":
                sb = new StringBuilder();
                sb.append(buff.getTurnLeft()).append("回合间，").append(getTargetName(targetParts)).
                        append("受到的治疗会转化为伤害。");
                if (noEffect) {
                    sb.append("（未生效）");
                }
                sb.append("\n");
                txtBattleInfo.append(sb.toString());
                break;
            case "REGIST":      // Accumulate.(?)
                sb = new StringBuilder();
                name = EnumBuff.getNameById(buff.getBuffName().substring(0, buff.getBuffName().indexOf("_REGIST")));
                sb.append(buff.getTurnLeft()).append("回合间，").append(getTargetName(targetParts)).
                        append("获得").append(buff.getValue()[0]).append("％").append(name).append("抗性。\n");
                txtBattleInfo.append(sb.toString());
                break;
            case "DEAL":
                if (noEffect) {
                    break;
                }
                sb = new StringBuilder();
                if (buff.getTurnLeft() > 1) {
                    sb.append(buff.getTurnLeft()).append("回合间，");
                }
                sb.append(getTargetName(targetParts)).append("的抽卡数量");
                if (buff.getValue()[0] > 0) {
                    sb.append("+");
                }
                sb.append(buff.getValue()[0]).append("。\n");
                txtBattleInfo.append(sb.toString());
                break;
            case "COVERING":
                sb = new StringBuilder();
                sb.append(buff.getTurnLeft()).append("回合间，对").append(getTargetName(targetParts)).
                        append("附加嘲讽效果，并减免伤害").append(buff.getValue()[0]).append("％。\n");
                txtBattleInfo.append(sb.toString());
                break;
            case "STAN":    // Do nothing. Text output is done above.
                break;
            case "TYPE_HIDE":
                sb = new StringBuilder();
                sb.append(buff.getTurnLeft());
                if (buff.isBuff()) {
                    sb.append("回合间，隐藏");
                } else {
                    sb.append("回合间，显示");
                }
                sb.append(getTargetName(targetParts)).append("的属性。\n");
                txtBattleInfo.append(sb.toString());
                break;
            case "REWRITE":
                sb = new StringBuilder();
                sb.append(buff.getTurnLeft()).append("回合间，改变").append(getTargetName(targetParts)).
                        append("的属性。\n");
                txtBattleInfo.append(sb.toString());
                break;
            case "ATTACK_BARRIER":  // Replace without any condition.
                sb = new StringBuilder();
                sb.append(buff.getTurnLeft()).append("回合间，为").append(getTargetName(targetParts)).
                        append("附加吸收").append(buff.getValue()[0]).append("伤害").
                        append(buff.getValue()[1]).append("次的").append(EnumPhysicsMagic.getNameByIndex(buff.getValue()[2])).append("免伤盾。\n");
                txtBattleInfo.append(sb.toString());
                break;
            case "DARKNESS":    // Not accumulate.
                if (noEffect) {
                    sb = new StringBuilder();
                    sb.append("黑暗状态对").append(getTargetName(targetParts)).append("无效。\b");
                    txtBattleInfo.append(sb.toString());
                    break;
                }
                sb = new StringBuilder();
                sb.append(buff.getTurnLeft()).append("回合间，").append(getTargetName(targetParts)).
                        append("的第");
                for (int i = 0; i < buff.getValue().length; i++) {
                    if (buff.getValue()[i] == 1) {
                        sb.append(i + 1).append("、");
                    }
                }
                sb.deleteCharAt(sb.length() - 1);
                sb.append("张卡牌黑暗。");
                sb.append("\n");
                txtBattleInfo.append(sb.toString());
                break;
            case "CARD_TRAP_DAMAGE":
                break;      // DO NOTHING
            case "CARD_SEAL":
                break;      // DO NOTHING
            case "RELEASE":
                sb = new StringBuilder();
                sb.append("解除").append(getTargetName(targetParts)).append("的");
                if (buff.getValue() == null && buff.isBuff()) {
                    sb.append("全部正面状态。");
                } else if (buff.getValue() == null && !buff.isBuff()) {
                    sb.append("全部负面状态。");
                } else {
                    sb.append(EnumBuff.getNameByIndex(buff.getValue()[0]));
                    if (buff.getValue().length > 1) {
                        sb.append("和").append(EnumBuff.getNameByIndex(buff.getValue()[1]));
                    }
                    sb.append("状态。");
                }
                if (noEffect) {
                    sb.append("（无效果）");
                }
                sb.append("\n");
                txtBattleInfo.append(sb.toString());
                break;
            case "COST_BLOCK":  // Replace.
                sb = new StringBuilder();
                sb.append(buff.getTurnLeft()).append("回合间，").append(getTargetName(targetParts)).
                        append("的COST上限降低").append(buff.getValue()[0]).append("。\n");
                txtBattleInfo.append(sb.toString());
                break;
            case "ENCHANT":
                sb = new StringBuilder();
                sb.append(buff.getTurnLeft()).append("回合间，").append(getTargetName(targetParts)).
                        append("的每次攻击追加").append(buff.getValue()[0]).append("点").
                        append(EnumType.getNameByIndex(buff.getValue()[1])).append("属性伤害。");
                if (noEffect) {
                    sb.append("（无效果）");
                }
                sb.append("\n");
                txtBattleInfo.append(sb.toString());
                break;
            case "DOT_VALUE_UP":    // Does not add, just change target's dot.
                sb = new StringBuilder();
                sb.append(getTargetName(targetParts)).
                        append("的").append(EnumBuff.getNameByIndex(buff.getValue()[1])).append("状态延长").
                        append(buff.getTurnLeft()).append("回合，且伤害提升").append(buff.getValue()[0]).append("％。");
                if (noEffect) {
                    sb.append("（无效果）");
                }
                sb.append("\n");
                txtBattleInfo.append(sb.toString());
                break;
            default:
                log.error("ERROR.");
                break;
        }
        return !noEffect;
    }

    /**
     *
     * @param buff
     * @param part
     * @return - True if the buff should be removed, false otherwise.
     */
    private void removeBuffEffectFromPart(BuffInfo buff, PartInfo part) {
        switch (buff.getType()) {
            case "ATTR_CHANGE":
                part.changeCurrentAttr(-buff.getValue()[0], buff.getValue()[1]);
                if (buff.getValue()[1].equals(EnumAttribute.MAX_HP.getIndex())
                        && part.getCurrentAttr(EnumAttribute.HP.getIndex()) > part.getCurrentAttr(EnumAttribute.MAX_HP.getIndex())) {
                    Integer val = part.getCurrentAttr(EnumAttribute.HP.getIndex()) - part.getCurrentAttr(EnumAttribute.MAX_HP.getIndex());
                    part.changeCurrentAttr(-val, EnumAttribute.HP.getIndex());
                }
                break;
            case "REGENERATE":
                // Do nothing. (Thus regeneration that last 1 turn has no effect.)
                break;
            case "DOT":
                // For enemy, add 1 turn resistance.
                if (!part.isArthur()) {
                    BuffInfo resistance = new BuffInfo(2, turn, "DOT_RESIST", null, buff.getBuffName() + "_RESIST", true);
                    if (!part.getBuffs().containsKey(resistance.getBuffName())) {
                        part.getBuffs().put(resistance.getBuffName(), new ArrayList<>());
                    }
                    part.getBuffs().get(resistance.getBuffName()).add(resistance);
                }
                break;
            case "DOT_RESIST":    // for enemy's dot resistance
                // Do nothing.
                break;
            case "WEAKNESS":    // NOTICE: only ONE PART is allowed in each side to have this debuff.
                // Do nothing.
                break;
            case "HEAL_REVERSE":
                // Do nothing.
                break;
            case "REGIST":      // Accumulate.(?)
                // Do nothing.
                break;
            case "DEAL":        // Replace - More card qty ones will replace less ones, and assume more turn would replace less turn ones.
                // Do nothing.
                break;
            case "COVERING":    // Replace without any condition.
                part.changeCurrentAttr(-part.getCurrentAttr(EnumAttribute.getIndexById("DDUC")), EnumAttribute.getIndexById("DDUC"));
                //part.getCurrentAttr()[EnumAttribute.getIndexById("DDUC")] = 0;
                break;
            case "STAN":        // Replace if succeed.
                // Do nothing.
                break;
            case "TYPE_HIDE":   // Replace without any condition.
                // Do nothing.
                break;
            case "REWRITE":
                part.setType(part.getOriginalType()); // RESET TYPE.
                break;
            case "ATTACK_BARRIER":  // Replace without any condition.
                // Do nothing.
                break;
            case "DARKNESS":    // Removed dark positions.
                for (int i = 0; i < 5; i++) {
                    if (buff.getValue()[i] == 1 && part.isArthur()) {
                        ((ArthurInfo) part).getDarknessPos()[i] = false;
                    }
                }
                break;
            case "CARD_TRAP_DAMAGE":
                // Remove traps in hand.
                for (int i = 0; i < 5; i++) {
                    if (buff.getValue()[i] == 1 && part.isArthur()) {
                        ((ArthurInfo) part).getHandCards()[i].setIsTrapped(0);
                    }
                }
                break;      // DO NOTHING
            case "CARD_SEAL":
                // Remove traps in hand.
                for (int i = 0; i < 5; i++) {
                    if (buff.getValue()[i] == 1 && part.isArthur()) {
                        ((ArthurInfo) part).getHandCards()[i].setIsSealed(0);
                    }
                }
                break;      // DO NOTHING
            case "RELEASE":
                log.error("ERROR.");    // SHOULD NOT happen.
                break;
            case "COST_BLOCK":  // Remove blocked value.
                ((ArthurInfo) part).setCostBlocked(0);
                break;
            case "ENCHANT": // DO NOTHING
                break;
            default:
                log.error("ERROR.");
                break;
        }
    }

    private void testOutputFirstRoundDeck(int i) {
        Collection<ArthurSkill> deck = arthurList.get(i).getDeck().values();
        List<String> firstRoundDeck = arthurList.get(i).getFirstRoundDeck();
        StringBuilder sb = new StringBuilder(), sbf = new StringBuilder();
        for (ArthurSkill car : deck) {
            sb.append(car.getCardName()).append(",");
        }
        for (String str : firstRoundDeck) {
            sbf.append(arthurList.get(i).getDeck().get(str).getCardName()).append(",");
        }
        sb.deleteCharAt(sb.length() - 1);
        sbf.deleteCharAt(sbf.length() - 1);
        log.debug(arthurList.get(i).getName());
        log.debug("Deck: " + sb.toString());
        log.debug("First Round: " + sbf.toString());
    }

    private void refreshEnemyUI() {
        for (int i = 0; i < enemyList.size(); i++) {
            enStatusProBar.get(i).setValue(enemyList.get(i).getCurrentAttr(0));
            enStatusHp.get(i).setText("HP：" + enemyList.get(i).getCurrentAttr(0) + " / " + enemyList.get(i).getCurrentAttr(7));
            enStatusAtk.get(i).setText("物攻：" + enemyList.get(i).getCurrentAttr(1));
            enStatusInt.get(i).setText("魔攻：" + enemyList.get(i).getCurrentAttr(2));
            StringBuilder sb = new StringBuilder();
            sb.append("增益：");
            StringBuilder sb2 = new StringBuilder();
            sb2.append("减益：");
            for (List<BuffInfo> buff : enemyList.get(i).getBuffs().values()) {
                if (!buff.isEmpty() && buff.get(0).isBuff()) {
                    sb.append(EnumBuff.getNameSById(buff.get(0).getBuffName())).append(" ");
                } else if (!buff.isEmpty() && !buff.get(0).isBuff()) {
                    sb2.append(EnumBuff.getNameSById(buff.get(0).getBuffName())).append(" ");
                }
            }
            if (sb.length() > 17) {
                String shortStr = sb.substring(0, 15);
                shortStr = shortStr.substring(0, shortStr.lastIndexOf(" ")) + " ...";
                enStatusBuff.get(i).setText(shortStr);
            } else {
                enStatusBuff.get(i).setText(sb.toString());
            }
            if (sb2.length() > 17) {
                String shortStr = sb2.substring(0, 15);
                shortStr = shortStr.substring(0, shortStr.lastIndexOf(" ")) + " ...";
                enStatusDebuff.get(i).setText(shortStr);
            } else {
                enStatusDebuff.get(i).setText(sb2.toString());
            }
            enStatusBuff.get(i).setToolTipText(sb.toString());
            enStatusDebuff.get(i).setToolTipText(sb2.toString());
            if (enemyList.get(i).getBuffs().containsKey("ATTR_HIDE") && !enemyList.get(i).getBuffs().get("ATTR_HIDE").isEmpty()
                    && (!enemyList.get(i).getBuffs().containsKey("ATTR_SEE") || enemyList.get(i).getBuffs().get("ATTR_SEE").isEmpty())) {
                enStatus.get(i).setColor2(GradientPanel.DEFAULT_MEDIUM);
                enStatus.get(i).setColor1(GradientPanel.DEFAULT_LIGHT);
            } else {
                enStatus.get(i).setColor2(EnumType.getColorById(enemyList.get(i).getType()));
                enStatus.get(i).setColor1(GradientPanel.DEFAULT_LIGHT);
            }
            sb = new StringBuilder();
            sb.append("<html>【").append(enemyList.get(i).getName()).append("】<br>");
            sb.append("物理攻击：").append(enemyList.get(i).getCurrentAttr(EnumAttribute.getIndexById("ATK"))).append("<br>");
            sb.append("魔法攻击：").append(enemyList.get(i).getCurrentAttr(EnumAttribute.getIndexById("INT"))).append("<br>");
            sb.append("　支援值：").append(enemyList.get(i).getCurrentAttr(EnumAttribute.getIndexById("MND"))).append("<br>");
            sb.append("物理防御：").append(enemyList.get(i).getCurrentAttr(EnumAttribute.getIndexById("DEF"))).append("<br>");
            sb.append("魔法防御：").append(enemyList.get(i).getCurrentAttr(EnumAttribute.getIndexById("MDEF"))).append("</html>");
            enStatus.get(i).setToolTipText(sb.toString());
            enStatus.get(i).repaint();
        }
    }

    private void refreshArthurUI() {
        for (int i = 0; i < arthurList.size(); i++) {
            if (arthurList.get(i).isDead()) {
                arStatusBuff.get(i).setText("");
                arStatusDebuff.get(i).setText("");
                arStatusCost.get(i).setText("");
                arStatusBuff.get(i).setToolTipText(null);
                arStatusDebuff.get(i).setToolTipText(null);
                arStatus.get(i).setToolTipText(null);
                arStatusTButton.get(i).setText("—被击破—");
                arStatusTButton.get(i).setEnabled(false);
                arStatusProBar.get(i).setValue(0);
                arStatusHp.get(i).setText("HP：0 / 0");
                continue;
            }
            arStatusTButton.get(i).setText("选择卡牌");
            arStatusProBar.get(i).setValue(arthurList.get(i).getCurrentAttr(0));
            arStatusHp.get(i).setText("HP：" + arthurList.get(i).getCurrentAttr(0) + " / " + arthurList.get(i).getCurrentAttr(7));
            StringBuilder sb = new StringBuilder();
            sb.append("增益：");
            StringBuilder sb2 = new StringBuilder();
            sb2.append("减益：");
            for (List<BuffInfo> buff : arthurList.get(i).getBuffs().values()) {
                if (!buff.isEmpty() && buff.get(0).isBuff()) {
                    sb.append(EnumBuff.getNameSById(buff.get(0).getBuffName())).append(" ");
                    if (EnumBuff.getNameSById(buff.get(0).getBuffName()) == null) {
                        log.info(buff.get(0).getBuffName());
                    }
                } else if (!buff.isEmpty() && !buff.get(0).isBuff()) {
                    sb2.append(EnumBuff.getNameSById(buff.get(0).getBuffName())).append(" ");
                    if (EnumBuff.getNameSById(buff.get(0).getBuffName()) == null) {
                        log.info(buff.get(0).getBuffName());
                    }
                }
            }
            if (sb.length() > 17) {
                String shortStr = sb.substring(0, 15);
                shortStr = shortStr.substring(0, shortStr.lastIndexOf(" ")) + "...";
                arStatusBuff.get(i).setText(shortStr);
            } else {
                arStatusBuff.get(i).setText(sb.toString());
            }
            if (sb2.length() > 17) {
                String shortStr = sb2.substring(0, 15);
                shortStr = shortStr.substring(0, shortStr.lastIndexOf(" ")) + "...";
                arStatusDebuff.get(i).setText(shortStr);
            } else {
                arStatusDebuff.get(i).setText(sb2.toString());
            }
            arStatusBuff.get(i).setToolTipText(sb.toString());
            arStatusDebuff.get(i).setToolTipText(sb2.toString());
            Integer cost = getTurnCost();
            arStatusCost.get(i).setText(getCostText(cost, arthurList.get(i).getCostUsed(), arthurList.get(i).getCostBlocked()));
            sb = new StringBuilder();
            sb.append("<html>【").append(arthurList.get(i).getName()).append("】<br>");
            sb.append("物理攻击：").append(arthurList.get(i).getCurrentAttr(EnumAttribute.getIndexById("ATK"))).append("<br>");
            sb.append("魔法攻击：").append(arthurList.get(i).getCurrentAttr(EnumAttribute.getIndexById("INT"))).append("<br>");
            sb.append("　治疗量：").append(arthurList.get(i).getCurrentAttr(EnumAttribute.getIndexById("MND"))).append("<br>");
            sb.append("物理防御：").append(arthurList.get(i).getCurrentAttr(EnumAttribute.getIndexById("DEF"))).append("<br>");
            sb.append("魔法防御：").append(arthurList.get(i).getCurrentAttr(EnumAttribute.getIndexById("MDEF")));
            if (arthurList.get(i).getCurrentAttr(EnumAttribute.getIndexById("CRIT")) > 0) {
                sb.append("<br>").append("　暴击率：").append(arthurList.get(i).getCurrentAttr(EnumAttribute.getIndexById("CRIT")));
            }
            if (arthurList.get(i).getCurrentAttr(EnumAttribute.getIndexById("DDUC")) > 0) {
                sb.append("<br>").append("伤害减免：").append(arthurList.get(i).getCurrentAttr(EnumAttribute.getIndexById("DDUC"))).append("％");
            }
            sb.append("</html>");
            arStatus.get(i).setToolTipText(sb.toString());
            arStatus.get(i).repaint();
        }
    }

    /**
     * Refresh Card Informations. May be called at beginning of each turn,
     * during card play, or switch card/sphere among Arthur(s).
     */
    private void refreshCardUI(int index) {
        ArthurInfo arthur = arthurList.get(index);
        Integer turnCost = getTurnCost();
        HandCardInfo[] handSource;
        HashMap<String, ArthurSkill> skillSource;
        StringBuilder sb;
        if (arthur.isDead()) {
            handSource = null;
            skillSource = null;
        } else if (showCards) {
            ((TitledBorder) panCards.getBorder()).setTitle("当前卡牌");
            handSource = arthur.getHandCards();
            skillSource = arthur.getDeck();
        } else {    // Show spheres
            ((TitledBorder) panCards.getBorder()).setTitle("当前Sphere");
            handSource = arthur.getHandSpheres();
            skillSource = arthur.getSpheres();
        }
        for (int i = 0; i < 5; i++) {
            if (handSource == null || handSource[i] == null) {
                btlCardName.get(i).setText("");
                btlCardInfo.get(i).setText("");
                btlCardValue.get(i).setText("");
                btlCardBonus.get(i).setText("");
                btlCardStatus.get(i).setText("");
                btlCardPanels.get(i).setToolTipText(null);
                btlCardPanels.get(i).setColor1(EnumType.getColorById("NONE"));
                btlCardPanels.get(i).setColor2(EnumType.getColorById("NONE"));
                btlCardAction.get(i).setVisible(false);
            } else {
                ArthurSkill arSkill = skillSource.get(handSource[i].getSkillId());
                List<String[]> skill = skillMap.get(handSource[i].getSkillId());
                if (!arthur.getDarknessPos()[i]) {
                    btlCardName.get(i).setText(arSkill.getCardName());
                    btlCardInfo.get(i).setText(arSkill.getBriefDescription());
                    btlCardValue.get(i).setText(handSource[i].getValue().toString());
                    sb = new StringBuilder();
                    sb.append(handSource[i].getCurrentChain() + 1).append("Chain");
                    if (handSource[i].getBoostPriority() > 0) {
                        sb.append(" | Boost!");
                    }
                    btlCardBonus.get(i).setText(sb.toString());
                    sb = new StringBuilder();
                    if (handSource[i].getIsSealed() > 0) {
                        sb.append("封印（").append(handSource[i].getIsSealed()).append("）");
                    }
                    if (handSource[i].getIsTrapped() > 0) {
                        if (handSource[i].getIsSealed() > 0) {
                            sb.append(" | ");
                        }
                        sb.append("陷阱（").append(handSource[i].getIsTrapped()).append("）");
                    }
                    if (sb.length() > 0) {
                        btlCardStatus.get(i).setText(sb.toString());
                    } else {
                        btlCardStatus.get(i).setText(" ");
                    }
                    btlCardPanels.get(i).setToolTipText(arSkill.getDescription());
                    String[] types = skill.get(0)[10].split("_");
                    btlCardPanels.get(i).setColor1(EnumType.getColorById(types[0]));
                    if (types.length > 1) {
                        btlCardPanels.get(i).setColor2(EnumType.getColorById(types[1]));
                    } else {
                        btlCardPanels.get(i).setColor2(EnumType.getColorById("NONE"));
                    }
                } else {
                    btlCardName.get(i).setText("■■■■■");
                    btlCardInfo.get(i).setText("■■■■■");
                    btlCardValue.get(i).setText("■■■■■");
                    sb = new StringBuilder();
                    sb.append(handSource[i].getCurrentChain() + 1).append("Chain");
                    if (handSource[i].getBoostPriority() > 0) {
                        sb.append(" | Boost!");
                    }
                    btlCardBonus.get(i).setText(sb.toString());
                    btlCardStatus.get(i).setText("■■■■■");
                    btlCardPanels.get(i).setToolTipText("■■■■■■■■■■");
                    btlCardPanels.get(i).setColor1(new Color(25, 25, 25));
                    btlCardPanels.get(i).setColor2(new Color(200, 200, 200));
                }

                btlCardAction.get(i).setVisible(true);
                btlCardAction.get(i).setSelected(handSource[i].isPlayed());
                if (!btlCardAction.get(i).isSelected() && (arSkill.getTurnAllowedAfter() >= turn
                        || (getTurnCost() - arthur.getCostUsed() - arthur.getCostBlocked() < Integer.parseInt(skill.get(0)[13])))) {
                    btlCardAction.get(i).setEnabled(false);
                } else if (handSource[i].getIsSealed() > 0) {
                    btlCardAction.get(i).setEnabled(false);
                } else {
                    btlCardAction.get(i).setEnabled(true);
                }
                if (handSource[i].getIsSealed() > 0) {
                    btlCardAction.get(i).setText("封印中");
                } else if (btlCardAction.get(i).isSelected()) {
                    btlCardAction.get(i).setText("已使用（" + handSource[i].getPlayedOrder() + "）");
                } else {
                    btlCardAction.get(i).setText("使用卡牌");
                }
            }
        }
        if (arthur.isDead()) {
            setBattleCmdCostText(0, 0, 0);
            arStatusCost.get(index).setText("");
            btnSwitch.setEnabled(false);
        } else {
            setBattleCmdCostText(turnCost, arthurList.get(index).getCostUsed(), arthurList.get(index).getCostBlocked());
            arStatusCost.get(index).setText(getCostText(turnCost, arthurList.get(index).getCostUsed(), arthurList.get(index).getCostBlocked()));
            btnSwitch.setEnabled(true);
        }
        panCards.repaint();
    }

    private void refreshTargetUI(Integer[][] targets) {
        if (targets == null) {
            panTargets.setEnabled(false);
            for (int i = 0; i < 4; i++) {
                targetButtons.get(i).setVisible(false);
            }
            return;
        }

        panTargets.setEnabled(true);
        for (int i = 0; i < 4; i++) {
            if (i >= targets.length) {
                targetButtons.get(i).setVisible(false);
                continue;
            }
            targetButtons.get(i).setVisible(true);
            String name;
            PartInfo part = null;
            if (targets[i][0] == 0) {
                name = arthurName[targets[i][1]];
                if (targets[i][1] != 4) {
                    part = arthurList.get(targets[i][1]);
                }
            } else {
                name = enemyName[targets[i][1]];
                if (targets[i][1] != 4) {
                    part = enemyList.get(targets[i][1]);
                }
            }

            if (part != null && part.isDead()) {
                targetButtons.get(i).setText(name + "(击破)");
                targetButtons.get(i).setEnabled(false);
            } else {
                targetButtons.get(i).setText(name);
                targetButtons.get(i).setEnabled(true);
            }

        }
    }

    // Try Play a skill (either card or sphere) at the given index position..
    private void tryPlayCard(int index) {
        ArthurInfo arthur = null;
        Integer arIndex = -1;
        playedIndex = index;
        for (int i = 0; i < 4; i++) {
            if (arStatusTButton.get(i).isSelected()) {
                arIndex = i;
            }
        }
        arthur = arthurList.get(arIndex);
        HandCardInfo card;
        if (showCards) {
            card = arthur.getHandCards()[index];
        } else {
            card = arthur.getHandSpheres()[index];
        }
        // Try play a card.
        if (btlCardAction.get(index).isSelected()) {
            List<String[]> skill = skillMap.get(card.getSkillId());
            String target = skill.get(0)[18];
            switch (target) {
                case "SELF":
                    playedTargets = new Integer[][]{{0, arIndex}};
                    break;
                case "USER_ONE":
                    playedTargets = new Integer[][]{{0, 0}, {0, 1}, {0, 2}, {0, 3}};
                    break;
                case "USER_ALL":
                    playedTargets = new Integer[][]{{0, 4}};
                    break;
                case "ENEMY_ONE":
                    playedTargets = new Integer[enemyList.size()][2];
                    for (int j = 0; j < enemyList.size(); j++) {
                        playedTargets[j] = new Integer[]{1, j};
                    }
                    break;
                case "ENEMY_ALL":
                    playedTargets = new Integer[][]{{1, 4}};
                    break;
                case "DEAD_ENEMY_ONE":
                    log.error("ERROR.");
                    break;
                case "DEAD_ENEMY_ALL":
                    log.error("ERROR.");
                    break;
                default:
                    log.error("ERROR.");
                    break;
            }
            refreshTargetUI(playedTargets);
            setOperationExceptTargetSelection(index, false);
        } else // Try cancel a card.
        {
            if (card.getTarget() != null) {
                card.setTarget(null);
                card.setIsPlayed(false);
                Integer playedOrder = card.getPlayedOrder();
                arthur.getCurrentPlayedItem().remove(playedOrder - 1);   // Since playedOrder start from 1.
                arthur.setCostUsed(arthur.getCostUsed()
                        - Integer.parseInt(skillMap.get(card.getSkillId()).get(0)[13]));

                for (HandCardInfo handCard : arthur.getHandCards()) {
                    if (handCard != null && handCard.getPlayedOrder() > playedOrder) {
                        handCard.setPlayedOrder(handCard.getPlayedOrder() - 1);
                    }
                }
                for (HandCardInfo handCard : arthur.getHandSpheres()) {
                    if (handCard != null && handCard.getPlayedOrder() > playedOrder) {
                        handCard.setPlayedOrder(handCard.getPlayedOrder() - 1);
                    }
                }

                // Compute all changes after cancel the skill.
                computeChains();
                computeIsBoost();
                computeSkillValues();
                refreshCardUI(arIndex);
            } else {
                setOperationExceptTargetSelection(index, true);
                refreshTargetUI(null);
                refreshCardUI(arIndex);
            }
        }
    }

    // Complete the play-card action (target selected).
    private void donePlayCard(int index) {
        ArthurInfo arthur = null;
        Integer arIndex = -1;
        //ArthurSkill arSkill;
        for (int i = 0; i < 4; i++) {
            if (arStatusTButton.get(i).isSelected()) {
                arIndex = i;
            }
        }
        arthur = arthurList.get(arIndex);
        HandCardInfo card;
        if (showCards) {
            card = arthur.getHandCards()[playedIndex];
            //arSkill = arthur.getDeck().get(card.getSkillId());
        } else {
            card = arthur.getHandSpheres()[playedIndex];
            //arSkill = arthur.getSpheres().get(card.getSkillId());
        }
        Integer[] target = playedTargets[index];
        card.setTarget(target);
        card.setIsPlayed(true);

        arthur.setCostUsed(arthur.getCostUsed() + Integer.parseInt(skillMap.get(card.getSkillId()).get(0)[13]));
        arthur.getCurrentPlayedItem().add(card);
        card.setPlayedOrder(arthur.getCurrentPlayedItem().size());

        // Compute all changes after playing the skill.
        computeChains();
        computeIsBoost();
        computeSkillValues();

        setOperationExceptTargetSelection(index, true);
        refreshTargetUI(null);
        refreshCardUI(arIndex);
    }

    // Go through all current cards in hand, and compute the chain count for each type.
    // Do not include sphere, as sphere does not gain bonus from chain.
    private void computeChains() {
        HashSet<String> typeSet;
        currentChains = new Boolean[][]{{false, false, false, false, false}, {false, false, false, false, false},
        {false, false, false, false, false}, {false, false, false, false, false}};
        // Compute card of each type.
        for (int i = 0; i < 4; i++) {
            ArthurInfo arthur = arthurList.get(i);
            typeSet = new HashSet<>();
            for (HandCardInfo card : arthur.getHandCards()) {
                if (card == null || !card.isPlayed()) {
                    continue;
                }
                String skillType = skillMap.get(card.getSkillId()).get(0)[10];
                Collections.addAll(typeSet, skillType.split("_"));
            }
            for (String type : typeSet) {
                currentChains[i][EnumType.getIndexById(type)] = true;
            }
        }

        // Compute Chain for each card.
        for (int i = 0; i < 4; i++) {
            ArthurInfo arthur = arthurList.get(i);
            for (HandCardInfo card : arthur.getHandCards()) {
                if (card == null) {
                    continue;
                }
                card.setCurrentChain(0);
                String skillType = skillMap.get(card.getSkillId()).get(0)[10];
                String[] skillTypes = skillType.split("_");
                Integer chain = 0;
                for (int j = 0; j < 4; j++) {
                    if (j == i) {
                        continue;   // Do not count own card as chain.
                    }
                    Boolean hasChain = false;
                    for (String type : skillTypes) {
                        if (currentChains[j][EnumType.getIndexById(type)]) {
                            hasChain = true;
                        }
                    }
                    if (hasChain) {
                        chain++;
                    }
                }
                card.setCurrentChain(chain);
            }
        }
    }

    // Go through all current cards in hand, check if the boost condition is matched.
    // Do not include sphere, as sphere does not have boost condition.
    private void computeIsBoost() {
        for (int i = 0; i < 4; i++) {
            ArthurInfo arthur = arthurList.get(i);
            for (HandCardInfo card : arthur.getHandCards()) {
                if (card == null) {
                    continue;
                }
                List<String[]> skills = skillMap.get(card.getSkillId());
                if (skills.size() == 1) {  // No boost skill
                    card.setBoostPriority(0);
                    continue;
                }
                String[] skill = skills.get(skills.size() - 1);
                card.setBoostPriority(checkIsBoost(skill, i, true, card.getTarget()));

            }
        }
    }

    // Go through all current cards/spheres in hand, and compute the main value to display.
    // The value computed including all current attr, but does NOT including chain effects.
    // The value is only for display and may different from the actual value used in battle (due to attr changes).
    // The skill may have more than one skill_role and value, but only display the main one.
    private void computeSkillValues() {
        Integer cardLevel;
        for (int i = 0; i < 4; i++) {
            ArthurInfo arthur = arthurList.get(i);
            for (HandCardInfo card : arthur.getHandCards()) {
                if (card == null) {
                    continue;
                }
                List<String[]> skills = skillMap.get(card.getSkillId());
                // ASSUMPTION: PRIORITY = INDEX OF THE SKILL ARRAY.
                String[] skill = skills.get(card.getBoostPriority());
                cardLevel = EnumCardLevel.getLevel(arthur.getDeck().get(card.getSkillId()).getRarity());
                card.setValue(computeFunctionValues(skill, cardLevel, arthur));
            }

            for (HandCardInfo card : arthur.getHandSpheres()) {
                if (card == null) {
                    continue;
                }
                List<String[]> skills = skillMap.get(card.getSkillId());
                // ASSUMPTION: PRIORITY = INDEX OF THE SKILL ARRAY.
                String[] skill = skills.get(card.getBoostPriority());
                cardLevel = EnumCardLevel.getLevel(arthur.getSpheres().get(card.getSkillId()).getRarity());
                card.setValue(computeFunctionValues(skill, cardLevel, arthur));
            }
        }
    }

    /**
     * Only apply to Arthur and skill main value. Many functions are empty --
     * leave for future changes.
     *
     * @return - An integer array to add to the values text.
     */
    private Integer computeFunctionValues(String[] skill, Integer cardLevel, ArthurInfo arthur) {
//        Integer[] attr = arthur.getCurrentAttr();
        Long val;
        Integer atkOpVal = 0;
        List<String[]> skillRoleList = skillRoleMap.get(skill[27]);
        for (String[] skillRole : skillRoleList) {
            String function = skillRole[SKILL_ROLE_FUNCTION_COL];
            switch (function) {
                case "REVIVE":
                    break;
                case "ATTACK_AA":
                    val = Long.parseLong(skillRole[SKILL_ROLE_PARAM1]) + Long.parseLong(skillRole[SKILL_ROLE_PARAM2]) * cardLevel / 1000;
                    val += Long.parseLong(skillRole[SKILL_ROLE_PARAM3]) * arthur.getCurrentAttr(EnumAttribute.getIndexById(skillRole[SKILL_ROLE_PARAM6])) / 1000;
                    log.debug("base: " + skillRole[SKILL_ROLE_PARAM1] + " | per level: " + skillRole[SKILL_ROLE_PARAM2] + " | cardLevel: " + cardLevel
                            + " | attr rate: " + Long.parseLong(skillRole[SKILL_ROLE_PARAM3]) + " | attr val: "
                            + arthur.getCurrentAttr(EnumAttribute.getIndexById(skillRole[SKILL_ROLE_PARAM6])) + " | final val: " + val);
                    return val.intValue() + atkOpVal;
                case "HP_CUT":
                    break;
                case "ATK_OP_DRAIN":
                    break;
                case "ATK_OP_PIERCING":
                    break;
                case "ATK_UP_FIXED":
                    val = Long.parseLong(skillRole[SKILL_ROLE_PARAM3]) * (Long.parseLong(skillRole[SKILL_ROLE_PARAM4]) + Long.parseLong(skillRole[SKILL_ROLE_PARAM5]) * cardLevel) / 1000;
                    return val.intValue();
                case "DEF_UP_FIXED":
                    val = Long.parseLong(skillRole[SKILL_ROLE_PARAM3]) * (Long.parseLong(skillRole[SKILL_ROLE_PARAM4]) + Long.parseLong(skillRole[SKILL_ROLE_PARAM5]) * cardLevel) / 1000;
                    return val.intValue();
                case "HEAL_FIXED":
                    val = Long.parseLong(skillRole[SKILL_ROLE_PARAM1]) + Long.parseLong(skillRole[SKILL_ROLE_PARAM2]) * cardLevel / 1000;
                    val += Long.parseLong(skillRole[SKILL_ROLE_PARAM3]) * arthur.getCurrentAttr(EnumAttribute.getIndexById(skillRole[SKILL_ROLE_PARAM5])) / 1000;
                    return val.intValue();
                case "ATK_BREAK_FIXED":
                    val = Long.parseLong(skillRole[SKILL_ROLE_PARAM3]) * (Long.parseLong(skillRole[SKILL_ROLE_PARAM4]) + Long.parseLong(skillRole[SKILL_ROLE_PARAM5]) * cardLevel) / 1000;
                    return val.intValue();
                case "GUARD_BREAK_FIXED":
                    val = Long.parseLong(skillRole[SKILL_ROLE_PARAM3]) * (Long.parseLong(skillRole[SKILL_ROLE_PARAM4]) + Long.parseLong(skillRole[SKILL_ROLE_PARAM5]) * cardLevel) / 1000;
                    return val.intValue();
                case "REGENERATE_FIXED":
                    val = Long.parseLong(skillRole[SKILL_ROLE_PARAM2]) + Long.parseLong(skillRole[SKILL_ROLE_PARAM3]) * cardLevel / 1000;
                    val += Long.parseLong(skillRole[SKILL_ROLE_PARAM4]) * arthur.getCurrentAttr(EnumAttribute.getIndexById(skillRole[SKILL_ROLE_PARAM6])) / 1000;
                    return val.intValue();
                case "ATK_UP_BY_SELF_PARAM":
                    val = Long.parseLong(skillRole[SKILL_ROLE_PARAM4]) * arthur.getCurrentAttr(EnumAttribute.getIndexById(skillRole[SKILL_ROLE_PARAM3])) / 1000;
                    val += Long.parseLong(skillRole[SKILL_ROLE_PARAM5]) + Integer.parseInt(skillRole[SKILL_ROLE_PARAM6]) * cardLevel;             // ？？
                    return val.intValue();
                case "DEF_UP_BY_SELF_PARAM":
                    val = Long.parseLong(skillRole[SKILL_ROLE_PARAM4]) * arthur.getCurrentAttr(EnumAttribute.getIndexById(skillRole[SKILL_ROLE_PARAM3])) / 1000;
                    val += Long.parseLong(skillRole[SKILL_ROLE_PARAM5]) + Integer.parseInt(skillRole[SKILL_ROLE_PARAM6]) * cardLevel;             // ？？
                    return val.intValue();
                case "HEAL_BY_SELF_PARAM":
                    break;
                case "ATK_BREAK_BY_SELF_PARAM":
                    val = Long.parseLong(skillRole[SKILL_ROLE_PARAM4]) * arthur.getCurrentAttr(EnumAttribute.getIndexById(skillRole[SKILL_ROLE_PARAM3])) / 1000;
                    val += Long.parseLong(skillRole[SKILL_ROLE_PARAM5]) + Integer.parseInt(skillRole[SKILL_ROLE_PARAM6]) * cardLevel;             // ？？
                    return val.intValue();
                case "GUARD_BREAK_BY_SELF_PARAM":
                    break;
                case "CRITICAL_UP":
                    break;
                case "ATK_OP_DAMAGE_INCREASE":
                    val = Long.parseLong(skillRole[SKILL_ROLE_PARAM3]) * arthur.getCurrentAttr(EnumAttribute.getIndexById(skillRole[SKILL_ROLE_PARAM5])) / 1000;
                    atkOpVal += val.intValue();
                    break;
                case "ATK_OP_REVENGE":
                    val = Long.parseLong(skillRole[SKILL_ROLE_PARAM1]) * arthur.getDamageTaken() / 100;
                    if (val > arthur.getCurrentAttr(EnumAttribute.getIndexById(skillRole[SKILL_ROLE_PARAM3])) * Long.parseLong(skillRole[SKILL_ROLE_PARAM4]) / 100) {
                        val = arthur.getCurrentAttr(EnumAttribute.getIndexById(skillRole[SKILL_ROLE_PARAM3])) * Long.parseLong(skillRole[SKILL_ROLE_PARAM4]) / 100;
                    }
                    atkOpVal += val.intValue();
                    break;
                case "ATK_OP_NOW_TURN_REVENGE":
                    break;
                case "HEAL_BY_TARGET_MAXHP":
                    break;
                case "BURN":
                    break;
                case "FREEZE":
                    break;
                case "BLEED":
                    break;
                case "POISON":
                    break;
                case "ELECTRIC":
                    break;
                case "WEAKNESS":
                    break;
                case "CARD_TRAP_DAMAGE":
                    break;
                case "CARD_SEAL":
                    break;
                case "DARKNESS_RANDOM":
                    break;
                case "DARKNESS_APPOINT":
                    break;
                case "HEAL_REVERSE":
                    break;
                case "BUFF_RELEASE":
                    break;
                case "BUFF_RELEASE_ONE":
                    break;
                case "DEBUFF_RELEASE":
                    break;
                case "DEBUFF_RELEASE_ONE":
                    break;
                case "CARD_SEAL_REGIST":
                    break;
                case "DARKNESS_REGIST":
                    break;
                case "COVERING":
                    return Integer.parseInt(skillRole[SKILL_ROLE_PARAM2]) / 10;
                case "STAN":
                    break;
                case "ATK_OP_ATTR_RATE_DOWN_INVALID":
                    break;
                case "ATTR_SEE":
                    break;
                case "ATTR_HIDE":
                    break;
                case "REWRITE":
                    break;
                case "DEAL_BONUS":
                    break;
                case "DEAL_PENALTY":
                    break;
                case "DEAL_PENALTY_TURN_APPOINT":
                    break;
                case "ENEMY_AI_TRIGGER_FLAG_SET":
                    break;
                case "ATTACK_BARRIER":
                    break;
                case "DESTRUCT":
                    break;
            }
        }
        return 0;
    }

    /**
     *
     * @param skill
     * @param partIndex
     * @return an Integer. 0 = not boosted, 1+ = boosted priority. priority
     */
    private Integer checkIsBoost(String[] skill, Integer partIndex, boolean isArthur, Integer[] skillTarget) {
        String skillId = skill[0];
        String condition = skill[20];
        String param1 = skill[21];
        String param2 = skill[22];
        int i;
        if (condition.isEmpty()) {
            log.error("ERROR.");  // Should not happen.
            return 0;
        }
        StringBuilder sb = new StringBuilder();
        switch (condition) {
            case "SELF_OTHER_PLAY_SKILL_KIND":  // APPLY TO ARTHUR
                i = 0;
                for (HandCardInfo card : arthurList.get(partIndex).getHandCards()) {
                    if (card != null && !card.getSkillId().equals(skillId) && card.isPlayed()
                            && skillMap.get(card.getSkillId()).get(0)[9].equals(param1)) {
                        i++;
                    }
                }
                if (i >= Integer.parseInt(param2)) {
                    return Integer.parseInt(skill[26]);
                }
                break;
            case "TURN":                        // APPLY TO BOTH
                if (param2.equals("0")) {
                    param2 = "999";
                }
                if (turn >= Integer.parseInt(param1) && turn <= Integer.parseInt(param2)) {
                    return Integer.parseInt(skill[26]);
                }
                break;
            case "SELF_HP_PER":                 // APPLY TO BOTH
                //Integer[] attr;
                PartInfo hpPart;
                if (isArthur) {
                    hpPart = arthurList.get(partIndex);
                    //attr = arthurList.get(partIndex).getCurrentAttr();
                } else {
                    hpPart = enemyList.get(partIndex);
                    //attr = enemyList.get(partIndex).getCurrentAttr();
                }
                double hpPer = (double) hpPart.getCurrentAttr(0) / hpPart.getCurrentAttr(7) * 100;
                if (param2.equals("0") || param2.isEmpty()) {
                    param2 = "200";
                }
                log.warn("WARN: " + skillId);
                if (hpPer >= Integer.parseInt(param1) && hpPer <= Integer.parseInt(param2)) {
                    return Integer.parseInt(skill[26]);
                }
                break;
            case "DECK_COMBO_COUNT":            // APPLY TO ARTHUR
                for (HandCardInfo card : arthurList.get(partIndex).getHandCards()) {
                    if (card != null && card.getSkillId().equals(skillId)
                            && (card.getCurrentChain() + 1) >= Integer.parseInt(param1)) {
                        return Integer.parseInt(skill[26]);
                    }
                }
                break;
            case "TARGET_DEBUFF":                 // APPLY TO BOTH
                List<PartInfo> targetParts = new ArrayList<>();
                // Add all target(s)' buffs into the list.
                if (skillTarget == null) {
                    break;
                } else if (skillTarget[0] == 1) {  // Target = enemy
                    if (skillTarget[1] != 4) {
                        targetParts.add(enemyList.get(skillTarget[1]));
                    } else {
                        targetParts.addAll(enemyList);
                    }
                } else if (skillTarget[1] != 4) {// target = user
                    targetParts.add(arthurList.get(skillTarget[1]));
                } else {
                    targetParts.addAll(arthurList);
                }
                // Check buffs.
                for (PartInfo part : targetParts) {
                    if (part.getBuffs().containsKey(param1) && !part.getBuffs().get(param1).isEmpty()) {
                        return Integer.parseInt(skill[26]);
                    }
                }
                break;
            case "TARGET_BUFF":               // APPLY TO BOTH
                targetParts = new ArrayList<>();
                // Add all target(s)' buffs into the list.
                if (skillTarget == null) {
                    break;
                } else if (skillTarget[0] == 1) {  // Target = enemy
                    if (skillTarget[1] != 4) {
                        targetParts.add(enemyList.get(skillTarget[1]));
                    } else {
                        targetParts.addAll(enemyList);
                    }
                } else if (skillTarget[1] != 4) {// target = user
                    targetParts.add(arthurList.get(skillTarget[1]));
                } else {
                    targetParts.addAll(arthurList);
                }
                // Check buffs.
                for (PartInfo part : targetParts) {
                    if (part.getBuffs().containsKey(param1) && !part.getBuffs().get(param1).isEmpty()) {
                        return Integer.parseInt(skill[26]);
                    }
                }
                break;
            case "TARGET_ATTR":                 // APPLY TO BOTH
                if (skillTarget == null) {
                    break;
                } else if (skillTarget[0] == 1) {  // Target = enemy
                    if (skillTarget[1] != 4) {
                        if (enemyList.get(skillTarget[1]).getType().equals(param1)) {
                            return Integer.parseInt(skill[26]);
                        }
                    } else {
                        for (EnemyInfo enemy : enemyList) {
                            if (enemy.getType().equals(param1)) {
                                return Integer.parseInt(skill[26]);
                            }
                        }
                    }
                } else {                    // TARGET_ATTR should not point to user.
                    log.error("ERROR.");
                }
                break;
            case "SELF_OTHER_PLAY_ATTR":            // APPLY TO ARTHUR
                i = 0;
                for (HandCardInfo card : arthurList.get(partIndex).getHandCards()) {
                    if (card != null && !card.getSkillId().equals(skillId) && card.isPlayed()) {
                        String[] types = skillMap.get(card.getSkillId()).get(0)[10].split("_");
                        for (String type : types) {
                            if (type.equals(param1)) {
                                i++;
                            }
                        }
                    }
                }
                if (i >= Integer.parseInt(param2)) {
                    return Integer.parseInt(skill[26]);
                }
                break;
            case "SELF_OTHER_PLAY_RARITY":          // APPLY TO ARTHUR
                i = 0;
                for (HandCardInfo card : arthurList.get(partIndex).getHandCards()) {
                    if (card != null && !card.getSkillId().equals(skillId) && card.isPlayed()) {
                        i++;
                    }
                }
                if (i >= Integer.parseInt(param2)) {
                    return Integer.parseInt(skill[26]);
                }
                break;
            case "RANDOM":                          // APPLY TO ENEMY
                Long prob = Math.round(Math.random() * 100 + 0.5);
                if (prob <= Integer.parseInt(param1)) {
                    return Integer.parseInt(skill[26]);
                }
                break;
            case "USER_SIDE_DEBUFF":               // APPLY TO BOTH
                for (ArthurInfo arthur : arthurList) {
                    if (arthur.getBuffs().containsKey(param1) && !arthur.getBuffs().get(param1).isEmpty()) {
                        return Integer.parseInt(skill[26]);
                    }
                }
                break;
            case "ENEMY_SIDE_DEBUFF":               // APPLY TO BOTH
                for (EnemyInfo enemy : enemyList) {
                    if (enemy.getBuffs().containsKey(param1) && !enemy.getBuffs().get(param1).isEmpty()) {
                        return Integer.parseInt(skill[26]);
                    }
                }
                break;
            case "SELF_ENEMY_AI_FLAG":              // APPLY TO ENEMY
                if (enemyTriggerAiFlag.containsKey(param1) && enemyTriggerAiFlag.get(param1).equals(1)) {
                    return Integer.parseInt(skill[26]);
                }
                break;
            case "SELF_DEBUFF":                     // APPLY TO BOTH
                HashMap<String, List<BuffInfo>> debuffs;
                if (isArthur) {
                    debuffs = arthurList.get(partIndex).getBuffs();
                } else {
                    debuffs = enemyList.get(partIndex).getBuffs();
                }
                // Check buffs.
                if (debuffs.containsKey(param1) && !debuffs.get(param1).isEmpty()) {
                    return Integer.parseInt(skill[26]);
                }
                break;
            case "SELF_BUFF":                     // APPLY TO BOTH
                HashMap<String, List<BuffInfo>> buffs;
                if (isArthur) {
                    buffs = arthurList.get(partIndex).getBuffs();
                } else {
                    buffs = enemyList.get(partIndex).getBuffs();
                }
                // Check buffs.
                if (buffs.containsKey(param1) && !buffs.get(param1).isEmpty()) {
                    return Integer.parseInt(skill[26]);
                }
                break;
            default:
                sb.append("checkIsBoost unrecognized: ").append(condition).append("\n");
                txtBattleInfo.append(sb.toString());
                log.error(sb.toString());
                break;
        }
        return 0;
    }

    private void switchHand() {
        showCards = !showCards;
        for (int i = 0; i < 4; i++) {
            if (arStatusTButton.get(i).isSelected()) {
                refreshCardUI(i);
            }
        }
    }

    private Integer getTurnCost() {
        Integer cost = turn + 2;
        if (cost > 10) {
            cost = 10;
        }
        return cost;
    }

    /**
     * Remove all buffs for user, and only debuffs for enemy.
     */
    private void clearBuffsForDead(PartInfo part) {
        if (part.isArthur()) {
            part.getBuffs().clear();
        } else {
            List<String> removeDebuff = new ArrayList<>();
            for (String str : part.getBuffs().keySet()) {
                removeDebuff.add(str);
            }
            for (String str : removeDebuff) {
                part.getBuffs().remove(str);
            }
        }
    }

    private String getCostText(Integer cost, Integer costUsed, Integer costBlocked) {
        StringBuilder sb = new StringBuilder();
        sb.append("COST：");
        for (int i = 0; i < cost - costUsed - costBlocked; i++) {
            sb.append("◆");
        }
        for (int i = cost - costUsed - costBlocked; i < cost - costBlocked; i++) {
            sb.append("◇");
        }
        for (int i = cost - costBlocked; i < cost; i++) {
            sb.append("×");
        }
        return sb.toString();
    }

    private void setBattleCmdCostText(Integer turnCost, Integer costUsed, Integer costBlocked) {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < Math.min(5, turnCost - costUsed - costBlocked); i++) {
            sb.append("◆");
        }
        for (int i = Math.min(5, turnCost - costUsed - costBlocked); i < Math.min(5, turnCost - costBlocked); i++) {
            sb.append("◇");
        }
        for (int i = Math.min(5, turnCost - costBlocked); i < Math.min(5, turnCost); i++) {
            sb.append("×");
        }
        lblCost.setText(sb.toString());
        sb = new StringBuilder();
        for (int i = 5; i < turnCost - costUsed - costBlocked; i++) {
            sb.append("◆");
        }
        for (int i = Math.max(5, turnCost - costUsed - costBlocked); i < Math.max(5, turnCost - costBlocked); i++) {
            sb.append("◇");
        }
        for (int i = Math.max(5, turnCost - costBlocked); i < Math.max(5, turnCost); i++) {
            sb.append("×");
        }
        lblCost2.setText(sb.toString());
    }

    private void sortCardOrderWithSamePriority(List<HandCardInfo> actionList) {
        int switchIndex;
        HandCardInfo actionToSwitch;
        HandCardInfo temp;
        int currentPriority;
        for (int i = 0; i < actionList.size(); i++) {
            currentPriority = actionList.get(i).getCardSkillPriority();
            actionToSwitch = actionList.get(i);
            switchIndex = -1;
            for (int j = i; j < actionList.size(); j++) {
                if (actionList.get(j).getCardSkillPriority() > currentPriority) {
                    break;
                }
                if (actionList.get(j).getSkill().getArthurIndex().equals(actionToSwitch.getSkill().getArthurIndex())
                        && actionList.get(j).getPlayedOrder() < actionToSwitch.getPlayedOrder()) {
                    actionToSwitch = actionList.get(j);
                    switchIndex = j;
                }
            }
            if (switchIndex != -1) {
                temp = actionList.set(switchIndex, actionList.get(i));
                actionList.set(i, temp);
            }
        }
    }

    /**
     * Check the battle condition.
     *
     * @return - 1 if user wins, 0 if still in battle, -1 if enemy wins.
     */
    private Integer isWin() {
        Boolean allPartDead = true;
        for (EnemyInfo enemy : enemyList) {
            if (!enemy.isDead() && enemy.getParent().equals(-1)) {
                allPartDead = false;
            }
        }
        if (allPartDead) {
            return 1;
        }

        allPartDead = true;
        for (ArthurInfo arthur : arthurList) {
            if (!arthur.isDead()) {
                allPartDead = false;
            }
        }
        if (allPartDead) {
            return -1;
        }

        return 0;
    }

    private void initPartBuffList() {
        for (PartInfo part : enemyList) {
            initPartBuff(part);
        }
        for (PartInfo part : arthurList) {
            initPartBuff(part);
        }
    }

    private void initPartBuff(PartInfo part) {
        part.setBuffs(new HashMap<>());
    }

    private String getTargetName(List<PartInfo> realTargetParts) {
        if (realTargetParts.size() > 1) {
            if (realTargetParts.get(0).isArthur()) {
                return "我方全体";
            } else {
                return "敌方全体";
            }
        } else {
            return realTargetParts.get(0).getName();
        }
    }

    private void setOperationExceptTargetSelection(Integer index, boolean allow) {
        for (int i = 0; i < 4; i++) {
            if (!arthurList.get(i).isDead()) {
                arStatusTButton.get(i).setEnabled(allow);
            }
        }
        for (int i = 0; i < 5; i++) {
            if (i != index) {
                btlCardAction.get(i).setEnabled(allow);
            }
        }
        btnSwitch.setEnabled(allow);
        if (playedIndex != null) {
            btlCardAction.get(playedIndex).requestFocus();
        }
        ((MainFrame) UIUtil.getMainFrame()).enableTestFunc(allow);
    }

    private void haltGame(boolean halt) {
        for (JToggleButton btn : arStatusTButton) {
            btn.setEnabled(!halt);
        }
        for (JToggleButton btn : btlCardAction) {
            btn.setEnabled(!halt);
        }
        btnSwitch.setEnabled(!halt);
        btnEndTurn.setEnabled(!halt);
        btnStartAgain.setEnabled(!halt);
    }

    private void startAgain() {
        if (JOptionPane.showConfirmDialog(this, "确定要重新开始吗？", "提醒", JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE)
                == JOptionPane.YES_OPTION) {
            enemyList = ((BattlePrepare) UIUtil.getBattlePrepare()).prepareEnemy(enemyPartyId);
            arthurList = ((BattlePrepare) UIUtil.getBattlePrepare()).prepareArthur();
            prepareBattle();
        }
    }

    private void returnToBattlePrepare() {
        if (JOptionPane.showConfirmDialog(this, "确定要返回战斗准备界面吗？", "提醒", JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE)
                == JOptionPane.YES_OPTION) {
            ((MainFrame) UIUtil.getMainFrame()).switchPanel("battle_prepare");
        }
    }

    private javax.swing.JLabel lblTitle;
    private javax.swing.JPanel panArthurStatus;
    private javax.swing.JPanel panBattleCmd;
    private javax.swing.JPanel panEnemyStatus;
    private javax.swing.JScrollPane scrPanEnemyStatus;
    private javax.swing.JScrollPane scrPaneBattleInfo;
    private javax.swing.JTextArea txtBattleInfo;

    // Arthur Status
    private List<GradientPanel> arStatus;
    private List<JProgressBar> arStatusProBar;
    private List<JToggleButton> arStatusTButton;
    private List<JLabel> arStatusBuff;
    private List<JLabel> arStatusDebuff;
    private List<JLabel> arStatusCost;
    private List<JLabel> arStatusHp;
    private List<GroupLayout> arStatusLayout;
    private JButton btnEndTurn;
    private JButton btnStartAgain;
    private JButton btnReturnToPrepare;
    private ButtonGroup arButtonGroup;

    // Battle Command
    private javax.swing.JButton btnSwitch;
    private List<JButton> targetButtons;
    private javax.swing.JLabel lblCost;
    private javax.swing.JLabel lblCost2;
    private JPanel panCards;
    private javax.swing.JPanel panCost;
    private javax.swing.JPanel panTargets;
    private List<GradientPanel> btlCardPanels;
    private List<JLabel> btlCardName;
    private List<JLabel> btlCardInfo;
    private List<JLabel> btlCardValue;
    private List<JLabel> btlCardStatus;
    private List<JLabel> btlCardBonus;
    private List<JToggleButton> btlCardAction;
    private List<GroupLayout> btlCardLayout;

    // Enemy Status
    private List<GradientPanel> enStatus;
    private List<JProgressBar> enStatusProBar;
    private List<JLabel> enStatusHp;
    private List<JLabel> enStatusAtk;
    private List<JLabel> enStatusInt;
    private List<JLabel> enStatusBuff;
    private List<JLabel> enStatusDebuff;
    private List<GroupLayout> enStatusLayout;

    private void initComponentsByCode() {
        arStatus = new ArrayList<>();
        arStatusProBar = new ArrayList<>();
        arStatusTButton = new ArrayList<>();
        arStatusBuff = new ArrayList<>();
        arStatusDebuff = new ArrayList<>();
        arStatusCost = new ArrayList<>();
        arStatusHp = new ArrayList<>();
        arStatusLayout = new ArrayList<>();
        btnReturnToPrepare = new JButton();
        btnEndTurn = new JButton();
        btnReturnToPrepare.setText("返回战斗准备界面");
        btnReturnToPrepare.setFont(defaultFont);
        btnEndTurn.setText("结束回合");
        btnEndTurn.setFont(defaultFont);
        btnStartAgain = new JButton();
        btnStartAgain.setText("重新开始");
        btnStartAgain.setFont(defaultFont);
        arButtonGroup = new ButtonGroup();

        panBattleCmd = new javax.swing.JPanel();
        panArthurStatus = new javax.swing.JPanel();
        //panEnemyStatus = new javax.swing.JPanel();
        panEnemyStatus = new javax.swing.JPanel();
        scrPanEnemyStatus = new javax.swing.JScrollPane();
        scrPanEnemyStatus.setViewportView(panEnemyStatus);
        scrPaneBattleInfo = new javax.swing.JScrollPane();
        txtBattleInfo = new javax.swing.JTextArea();
        lblTitle = new javax.swing.JLabel();

        for (int i = 0; i < 4; i++) {
            arStatus.add(new GradientPanel());
            arStatus.get(i).setDirection(0);
            arStatus.get(i).setPoint2(1f);
            arStatus.get(i).setColor2(GradientPanel.DEFAULT_LIGHT2);
            arStatus.get(i).setColor1(GradientPanel.DEFAULT_LIGHT);
            arStatusProBar.add(new JProgressBar());
            arStatusTButton.add(new JToggleButton());
            arStatusBuff.add(new JLabel());
            arStatusDebuff.add(new JLabel());
            arStatusCost.add(new JLabel());
            arStatusHp.add(new JLabel());

            arButtonGroup.add(arStatusTButton.get(i));
            arStatus.get(i).setBorder(BorderFactory.createTitledBorder(EnumArthur.getNameByIndex(i)));
            ((TitledBorder) arStatus.get(i).getBorder()).setTitleFont(new java.awt.Font("宋体", 0, 12));
            ((TitledBorder) arStatus.get(i).getBorder()).setTitleColor(new Color(30, 120, 30));
            arStatusCost.get(i).setFont(defaultFont);

            arStatusProBar.get(i).setMinimum(0);
            arStatusProBar.get(i).setMaximum(100);
            arStatusProBar.get(i).setValue(50);
            arStatusTButton.get(i).setFont(defaultFont);
            arStatusBuff.get(i).setText("  增益:");
            arStatusBuff.get(i).setFont(defaultFont);
            arStatusDebuff.get(i).setText("  减益:");
            arStatusDebuff.get(i).setFont(defaultFont);
            arStatusCost.get(i).setText("  COST: 3 / 3");
            arStatusCost.get(i).setFont(defaultFont);
            arStatusHp.get(i).setText("  HP: 23333 / 23333");
            arStatusHp.get(i).setFont(defaultFont);

            arStatusLayout.add(new javax.swing.GroupLayout(arStatus.get(i)));
            arStatus.get(i).setLayout(arStatusLayout.get(i));
            arStatusLayout.get(i).setHorizontalGroup(
                    arStatusLayout.get(i).createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(arStatusLayout.get(i).createSequentialGroup()
                            .addGroup(arStatusLayout.get(i).createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, true)
                                    .addComponent(arStatusTButton.get(i), javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                    .addComponent(arStatusBuff.get(i), javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                    .addComponent(arStatusDebuff.get(i), javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                    .addComponent(arStatusHp.get(i), javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                    .addComponent(arStatusCost.get(i), javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                    .addComponent(arStatusProBar.get(i), javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                            .addGap(0, 5, 5))
            );
            arStatusLayout.get(i).setVerticalGroup(
                    arStatusLayout.get(i).createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, arStatusLayout.get(i).createSequentialGroup()
                            .addComponent(arStatusHp.get(i), javax.swing.GroupLayout.PREFERRED_SIZE, 20, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(arStatusProBar.get(i), javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(arStatusBuff.get(i), javax.swing.GroupLayout.PREFERRED_SIZE, 20, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addGap(0, 0, 0)
                            .addComponent(arStatusDebuff.get(i), javax.swing.GroupLayout.PREFERRED_SIZE, 20, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addGap(0, 0, 0)
                            .addGap(0, 0, 0)
                            .addComponent(arStatusCost.get(i), javax.swing.GroupLayout.PREFERRED_SIZE, 20, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(arStatusTButton.get(i), 20, 30, javax.swing.GroupLayout.PREFERRED_SIZE))
            );
        }

        panArthurStatus.setBorder(javax.swing.BorderFactory.createTitledBorder("我方状态"));
        ((TitledBorder) panArthurStatus.getBorder()).setTitleFont(new java.awt.Font("宋体", 0, 12));
        javax.swing.GroupLayout panArthurStatusLayout = new javax.swing.GroupLayout(panArthurStatus);
        panArthurStatus.setLayout(panArthurStatusLayout);
        panArthurStatusLayout.setHorizontalGroup(panArthurStatusLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(panArthurStatusLayout.createSequentialGroup()
                        .addGap(0, 0, 0)
                        .addGroup(panArthurStatusLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                .addComponent(arStatus.get(0), 100, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                .addComponent(arStatus.get(1), 100, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                .addComponent(arStatus.get(2), 100, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                .addComponent(arStatus.get(3), 100, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                .addComponent(btnEndTurn, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                .addComponent(btnStartAgain, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                .addComponent(btnReturnToPrepare, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                        .addGap(0, 0, 0))
        );
        panArthurStatusLayout.setVerticalGroup(panArthurStatusLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, panArthurStatusLayout.createSequentialGroup()
                        .addGap(0, 0, 0)
                        .addComponent(arStatus.get(0), 60, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(arStatus.get(1), 60, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(arStatus.get(2), 60, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(arStatus.get(3), 60, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(10, 10, 10)
                        .addComponent(btnEndTurn, 20, 40, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(0, 0, Short.MAX_VALUE)
                        .addComponent(btnStartAgain, 20, 40, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addComponent(btnReturnToPrepare, 20, 40, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(0, 0, 0))
        );

        // Battle Command Layout
        panCards = new JPanel();
        btnSwitch = new javax.swing.JButton();
        panTargets = new javax.swing.JPanel();
        targetButtons = new ArrayList<>();
        panCost = new javax.swing.JPanel();
        lblCost = new javax.swing.JLabel();
        lblCost2 = new javax.swing.JLabel();
        btlCardPanels = new ArrayList<>();
        btlCardName = new ArrayList<>();
        btlCardInfo = new ArrayList<>();
        btlCardValue = new ArrayList<>();
        btlCardStatus = new ArrayList<>();
        btlCardBonus = new ArrayList<>();
        btlCardAction = new ArrayList<>();
        btlCardLayout = new ArrayList<>();

        for (int i = 0; i < 4; i++) {
            targetButtons.add(new JButton());
            targetButtons.get(i).setFont(defaultFont);
            //targetButtons.get(i).setText(EnumArthur.getNameByIndex(i));     // Will change during battle.
        }
        for (int i = 0; i < 5; i++) {
            btlCardPanels.add(new GradientPanel());
            btlCardPanels.get(i).setDirection(0);
            btlCardPanels.get(i).setPoint2(1.6f);
            btlCardName.add(new JLabel());
            btlCardInfo.add(new JLabel());
            btlCardValue.add(new JLabel());
            btlCardStatus.add(new JLabel());
            btlCardBonus.add(new JLabel());
            btlCardAction.add(new JToggleButton());

            btlCardPanels.get(i).setBorder(javax.swing.BorderFactory.createTitledBorder(""));
            btlCardPanels.get(i).setBackground(new Color(230, 230, 230));
            btlCardName.get(i).setHorizontalAlignment(SwingConstants.CENTER);
            btlCardName.get(i).setFont(defaultFont);
            btlCardName.get(i).setForeground(new Color(0, 0, 255));
            btlCardInfo.get(i).setHorizontalAlignment(SwingConstants.CENTER);
            btlCardInfo.get(i).setFont(defaultFont);
            btlCardValue.get(i).setHorizontalAlignment(SwingConstants.CENTER);
            btlCardValue.get(i).setFont(defaultFont);
            btlCardStatus.get(i).setHorizontalAlignment(SwingConstants.CENTER);
            btlCardStatus.get(i).setFont(defaultFont);
            btlCardBonus.get(i).setHorizontalAlignment(SwingConstants.CENTER);
            btlCardBonus.get(i).setFont(defaultFont);
            btlCardAction.get(i).setFont(defaultFont);

            btlCardLayout.add(new javax.swing.GroupLayout(btlCardPanels.get(i)));
            btlCardPanels.get(i).setLayout(btlCardLayout.get(i));
            btlCardLayout.get(i).setHorizontalGroup(
                    btlCardLayout.get(i).createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(btlCardName.get(i), javax.swing.GroupLayout.PREFERRED_SIZE, 80, Short.MAX_VALUE)
                    .addComponent(btlCardInfo.get(i), javax.swing.GroupLayout.PREFERRED_SIZE, 80, Short.MAX_VALUE)
                    .addComponent(btlCardValue.get(i), javax.swing.GroupLayout.PREFERRED_SIZE, 80, Short.MAX_VALUE)
                    .addComponent(btlCardBonus.get(i), javax.swing.GroupLayout.PREFERRED_SIZE, 80, Short.MAX_VALUE)
                    .addComponent(btlCardStatus.get(i), javax.swing.GroupLayout.PREFERRED_SIZE, 80, Short.MAX_VALUE)
                    .addComponent(btlCardAction.get(i), javax.swing.GroupLayout.PREFERRED_SIZE, 80, Short.MAX_VALUE)
            );
            btlCardLayout.get(i).setVerticalGroup(
                    btlCardLayout.get(i).createSequentialGroup()
                    .addComponent(btlCardName.get(i), javax.swing.GroupLayout.PREFERRED_SIZE, GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(btlCardInfo.get(i), javax.swing.GroupLayout.PREFERRED_SIZE, GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(btlCardValue.get(i), javax.swing.GroupLayout.PREFERRED_SIZE, GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(btlCardBonus.get(i), javax.swing.GroupLayout.PREFERRED_SIZE, GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(btlCardStatus.get(i), javax.swing.GroupLayout.PREFERRED_SIZE, GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(btlCardAction.get(i), javax.swing.GroupLayout.PREFERRED_SIZE, GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
            );
        }

        panCards.setBorder(javax.swing.BorderFactory.createTitledBorder("当前卡牌"));
        ((TitledBorder) panCards.getBorder()).setTitleFont(new java.awt.Font("宋体", 0, 12));
        javax.swing.GroupLayout panCardsLayout = new javax.swing.GroupLayout(panCards);
        panCards.setLayout(panCardsLayout);
        panCardsLayout.setHorizontalGroup(
                panCardsLayout.createSequentialGroup()
                .addGap(5, 5, 5)
                .addComponent(btlCardPanels.get(0), javax.swing.GroupLayout.PREFERRED_SIZE, 80, Short.MAX_VALUE)
                .addGap(5, 5, 5)
                .addComponent(btlCardPanels.get(1), javax.swing.GroupLayout.PREFERRED_SIZE, 80, Short.MAX_VALUE)
                .addGap(5, 5, 5)
                .addComponent(btlCardPanels.get(2), javax.swing.GroupLayout.PREFERRED_SIZE, 80, Short.MAX_VALUE)
                .addGap(5, 5, 5)
                .addComponent(btlCardPanels.get(3), javax.swing.GroupLayout.PREFERRED_SIZE, 80, Short.MAX_VALUE)
                .addGap(5, 5, 5)
                .addComponent(btlCardPanels.get(4), javax.swing.GroupLayout.PREFERRED_SIZE, 80, Short.MAX_VALUE)
                .addGap(5, 5, 5)
        );
        panCardsLayout.setVerticalGroup(
                panCardsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addComponent(btlCardPanels.get(0), javax.swing.GroupLayout.PREFERRED_SIZE, 80, Short.MAX_VALUE)
                .addComponent(btlCardPanels.get(1), javax.swing.GroupLayout.PREFERRED_SIZE, 80, Short.MAX_VALUE)
                .addComponent(btlCardPanels.get(2), javax.swing.GroupLayout.PREFERRED_SIZE, 80, Short.MAX_VALUE)
                .addComponent(btlCardPanels.get(3), javax.swing.GroupLayout.PREFERRED_SIZE, 80, Short.MAX_VALUE)
                .addComponent(btlCardPanels.get(4), javax.swing.GroupLayout.PREFERRED_SIZE, 80, Short.MAX_VALUE)
        );

        btnSwitch.setText("卡牌/Sphere");
        btnSwitch.setFont(defaultFont);

        javax.swing.GroupLayout panTargetsLayout = new javax.swing.GroupLayout(panTargets);
        panTargets.setBorder(javax.swing.BorderFactory.createTitledBorder("目标选择"));
        ((TitledBorder) panTargets.getBorder()).setTitleFont(new java.awt.Font("宋体", 0, 12));
        panTargets.setLayout(panTargetsLayout);
        JLabel tempLabel = new JLabel();
        panTargetsLayout.setHorizontalGroup(
                panTargetsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(panTargetsLayout.createSequentialGroup()
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(targetButtons.get(0), javax.swing.GroupLayout.PREFERRED_SIZE, 140, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(targetButtons.get(1), javax.swing.GroupLayout.PREFERRED_SIZE, 140, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(targetButtons.get(2), javax.swing.GroupLayout.PREFERRED_SIZE, 140, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(targetButtons.get(3), javax.swing.GroupLayout.PREFERRED_SIZE, 140, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(tempLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 50, javax.swing.GroupLayout.PREFERRED_SIZE))
        );
        panTargetsLayout.setVerticalGroup(
                panTargetsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(panTargetsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                        .addComponent(targetButtons.get(0), javax.swing.GroupLayout.PREFERRED_SIZE, 30, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addComponent(targetButtons.get(1), javax.swing.GroupLayout.PREFERRED_SIZE, 30, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addComponent(targetButtons.get(2), javax.swing.GroupLayout.PREFERRED_SIZE, 30, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addComponent(targetButtons.get(3), javax.swing.GroupLayout.PREFERRED_SIZE, 30, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addComponent(tempLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 30, javax.swing.GroupLayout.PREFERRED_SIZE))
        );

        panCost.setBorder(javax.swing.BorderFactory.createTitledBorder("COST"));
        lblCost.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        lblCost.setFont(new java.awt.Font("宋体", 0, 14));
        lblCost.setForeground(new Color(0, 0, 255));
        lblCost2.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        lblCost2.setFont(new java.awt.Font("宋体", 0, 14));
        lblCost2.setForeground(new Color(0, 0, 255));
        lblCost.setText("◆◆◆");

        javax.swing.GroupLayout panCostLayout = new javax.swing.GroupLayout(panCost);
        panCost.setLayout(panCostLayout);
        panCostLayout.setHorizontalGroup(
                panCostLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGap(5, 5, 5)
                .addComponent(lblCost, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(lblCost2, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addGap(5, 5, 5)
        );
        panCostLayout.setVerticalGroup(
                panCostLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(panCostLayout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(lblCost, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(lblCost2, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addContainerGap())
        );

        panBattleCmd.setBorder(javax.swing.BorderFactory.createTitledBorder("战斗操作界面"));
        ((TitledBorder) panBattleCmd.getBorder()).setTitleFont(new java.awt.Font("宋体", 0, 12));
        javax.swing.GroupLayout panBattleCmdLayout = new javax.swing.GroupLayout(panBattleCmd);
        panBattleCmd.setLayout(panBattleCmdLayout);
        panBattleCmdLayout.setHorizontalGroup(
                panBattleCmdLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, panBattleCmdLayout.createSequentialGroup()
                        .addGroup(panBattleCmdLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                .addGroup(panBattleCmdLayout.createSequentialGroup()
                                        .addGroup(panBattleCmdLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                                .addComponent(panCost, javax.swing.GroupLayout.DEFAULT_SIZE, 90, javax.swing.GroupLayout.PREFERRED_SIZE)
                                                .addComponent(btnSwitch, javax.swing.GroupLayout.DEFAULT_SIZE, 95, javax.swing.GroupLayout.PREFERRED_SIZE))
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                        .addComponent(panCards, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                                .addComponent(panTargets, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)))
        );
        panBattleCmdLayout.setVerticalGroup(
                panBattleCmdLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(panBattleCmdLayout.createSequentialGroup()
                        .addGroup(panBattleCmdLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, true)
                                .addGroup(panBattleCmdLayout.createSequentialGroup()
                                        .addComponent(btnSwitch, javax.swing.GroupLayout.PREFERRED_SIZE, 90, javax.swing.GroupLayout.PREFERRED_SIZE)
                                        .addGap(4, 4, 4)
                                        .addComponent(panCost, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                                .addComponent(panCards, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                        .addComponent(panTargets, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(4, 4, 4))
        );

        // Enemy Status layout
        enStatus = new ArrayList<>();
        enStatusProBar = new ArrayList<>();
        enStatusHp = new ArrayList<>();
        enStatusAtk = new ArrayList<>();
        enStatusInt = new ArrayList<>();
        enStatusBuff = new ArrayList<>();
        enStatusDebuff = new ArrayList<>();
        enStatusLayout = new ArrayList<>();
        panEnemyStatus.setBorder(javax.swing.BorderFactory.createTitledBorder("外敌状态"));
        ((TitledBorder) panEnemyStatus.getBorder()).setTitleFont(new java.awt.Font("宋体", 0, 12));
        //panEnemyStatus.setBorder(null);
        scrPanEnemyStatus.setBorder(null);

        for (int i = 0; i < 4; i++) {
            enStatus.add(new GradientPanel());
            enStatus.get(i).setDirection(0);
            enStatus.get(i).setPoint2(1f);
            enStatusProBar.add(new JProgressBar());
            enStatusHp.add(new JLabel());
            enStatusAtk.add(new JLabel());
            enStatusInt.add(new JLabel());
            enStatusBuff.add(new JLabel());
            enStatusDebuff.add(new JLabel());

            enStatusProBar.get(i).setMinimum(0);
            enStatusProBar.get(i).setMaximum(100);
            enStatusProBar.get(i).setValue(50);
            enStatusAtk.get(i).setText("  物攻:");
            enStatusAtk.get(i).setFont(defaultFont);
            enStatusInt.get(i).setText("  魔攻:");
            enStatusInt.get(i).setFont(defaultFont);
            enStatusBuff.get(i).setText("  增益:");
            enStatusBuff.get(i).setFont(defaultFont);
            enStatusDebuff.get(i).setText("  减益:");
            enStatusDebuff.get(i).setFont(defaultFont);
            enStatusHp.get(i).setText("  HP: 1233333 / 2333333");
            enStatusHp.get(i).setFont(defaultFont);

            enStatus.get(i).setBorder(javax.swing.BorderFactory.createTitledBorder("敌部件：" + i));
            ((TitledBorder) enStatus.get(i).getBorder()).setTitleFont(new java.awt.Font("宋体", 0, 12));
            ((TitledBorder) enStatus.get(i).getBorder()).setTitleColor(new Color(180, 50, 50));
            enStatusLayout.add(new javax.swing.GroupLayout(enStatus.get(i)));
            enStatus.get(i).setLayout(enStatusLayout.get(i));
            enStatusLayout.get(i).setHorizontalGroup(
                    enStatusLayout.get(i).createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(enStatusLayout.get(i).createSequentialGroup()
                            .addGroup(enStatusLayout.get(i).createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, true)
                                    .addComponent(enStatusHp.get(i), javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                    .addComponent(enStatusProBar.get(i), javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                    .addGroup(enStatusLayout.get(i).createSequentialGroup()
                                            .addComponent(enStatusAtk.get(i), javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                            .addComponent(enStatusInt.get(i), javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                                    .addComponent(enStatusBuff.get(i), javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                    .addComponent(enStatusDebuff.get(i), javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                            .addGap(0, 5, 5))
            );
            enStatusLayout.get(i).setVerticalGroup(
                    enStatusLayout.get(i).createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, enStatusLayout.get(i).createSequentialGroup()
                            .addComponent(enStatusHp.get(i), javax.swing.GroupLayout.PREFERRED_SIZE, 20, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(enStatusProBar.get(i), javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addGroup(enStatusLayout.get(i).createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, true)
                                    .addComponent(enStatusAtk.get(i), 0, 20, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addComponent(enStatusInt.get(i), 0, 20, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addComponent(enStatusBuff.get(i), javax.swing.GroupLayout.PREFERRED_SIZE, 20, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(enStatusDebuff.get(i), javax.swing.GroupLayout.PREFERRED_SIZE, 20, javax.swing.GroupLayout.PREFERRED_SIZE))
            );
        }

        javax.swing.GroupLayout panEnemyStatusLayout = new javax.swing.GroupLayout(panEnemyStatus);
        panEnemyStatus.setLayout(panEnemyStatusLayout);
        panEnemyStatusLayout.setHorizontalGroup(
                panEnemyStatusLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(panEnemyStatusLayout.createSequentialGroup()
                        .addGap(0, 0, 0)
                        .addGroup(panEnemyStatusLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                .addComponent(enStatus.get(0), javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                .addComponent(enStatus.get(1), javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                .addComponent(enStatus.get(2), javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                .addComponent(enStatus.get(3), javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                        .addGap(0, 0, 0))
        );
        panEnemyStatusLayout.setVerticalGroup(
                panEnemyStatusLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, panEnemyStatusLayout.createSequentialGroup()
                        .addGap(0, 0, 0)
                        .addComponent(enStatus.get(0), javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(enStatus.get(1), javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(enStatus.get(2), javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(enStatus.get(3), javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(0, 0, Short.MAX_VALUE))
        );

        scrPaneBattleInfo.setBorder(javax.swing.BorderFactory.createTitledBorder("战斗信息"));
        ((TitledBorder) scrPaneBattleInfo.getBorder()).setTitleFont(new java.awt.Font("宋体", 0, 12));
        txtBattleInfo.setBackground(new java.awt.Color(240, 240, 240));
        txtBattleInfo.setColumns(20);
        txtBattleInfo.setFont(new java.awt.Font("宋体", 0, 12)); // NOI18N
        txtBattleInfo.setRows(5);
        scrPaneBattleInfo.setViewportView(txtBattleInfo);

        lblTitle.setFont(new java.awt.Font("宋体", 1, 16));
        lblTitle.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        lblTitle.setText("第1回合");
        lblTitle.setBorder(javax.swing.BorderFactory.createTitledBorder(""));

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
                layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(layout.createSequentialGroup()
                        .addComponent(panArthurStatus, javax.swing.GroupLayout.PREFERRED_SIZE, 220, javax.swing.GroupLayout.PREFERRED_SIZE)
                        //.addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGap(3, 3, 3)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                .addGroup(layout.createSequentialGroup()
                                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                                .addComponent(scrPaneBattleInfo, javax.swing.GroupLayout.DEFAULT_SIZE, 389, Short.MAX_VALUE)
                                                .addGroup(layout.createSequentialGroup()
                                                        .addGap(3, 3, 3)
                                                        .addComponent(lblTitle, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                                        .addGap(3, 3, 3)))
                                        //.addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                        .addGap(3, 3, 3)
                                        .addComponent(scrPanEnemyStatus, javax.swing.GroupLayout.PREFERRED_SIZE, 220, javax.swing.GroupLayout.PREFERRED_SIZE))
                                .addComponent(panBattleCmd, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)))
        );
        layout.setVerticalGroup(
                layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                                .addComponent(scrPanEnemyStatus, javax.swing.GroupLayout.PREFERRED_SIZE, 100, Short.MAX_VALUE)
                                .addGroup(layout.createSequentialGroup()
                                        .addGap(6, 6, 6)
                                        .addComponent(lblTitle, javax.swing.GroupLayout.DEFAULT_SIZE, 30, 30)
                                        .addGap(0, 0, 0)
                                        .addComponent(scrPaneBattleInfo, javax.swing.GroupLayout.PREFERRED_SIZE, 100, Short.MAX_VALUE)))
                        .addGap(5, 5, 5)
                        .addComponent(panBattleCmd, javax.swing.GroupLayout.PREFERRED_SIZE, 260, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addComponent(panArthurStatus, javax.swing.GroupLayout.PREFERRED_SIZE, 100, Short.MAX_VALUE)
        );
    }

    private void initListener() {
        txtBattleInfo.setEditable(false);

        for (int i = 0; i < 4; i++) {
            final int j = i;
            arStatusTButton.get(i).addActionListener((java.awt.event.ActionEvent evt) -> {
                refreshCardUI(j);
            });
        }

        for (int i = 0; i < 5; i++) {
            final int j = i;
            btlCardAction.get(i).addActionListener((java.awt.event.ActionEvent evt) -> {
                tryPlayCard(j);
            });
            btlCardPanels.get(i).addMouseListener(new CardPanelMouseAdapter(i));
        }

        for (int i = 0; i < 4; i++) {
            final int j = i;
            targetButtons.get(i).addActionListener((java.awt.event.ActionEvent evt) -> {
                donePlayCard(j);
            });
        }

        btnSwitch.addActionListener((java.awt.event.ActionEvent evt) -> {
            switchHand();
        });

        btnEndTurn.addActionListener((java.awt.event.ActionEvent evt) -> {
            endTurn();
        });

        btnReturnToPrepare.addActionListener((java.awt.event.ActionEvent evt) -> {
            returnToBattlePrepare();
        });

        btnStartAgain.addActionListener((java.awt.event.ActionEvent evt) -> {
            startAgain();
        });
    }

//    public static void main(String[] args) {
//        // Determine action play order.
//        HashMap<String, List<String[]>> skillMap = FileUtils.loadListMap("skill.csv");
//        List<HandCardInfo> actionList = new ArrayList<>();
//        HandCardInfo card = new HandCardInfo();
//        card.setSkillId("11400332");
//        card.setSkillName("猫耳型橄榄石");
//        card.setBoostPriority(1);
//        card.setPlayedOrder(0);
//        card.setSkill(new ArthurSkill());
//        card.getSkill().setArthurIndex(0);
//        getPriorityTest(skillMap, card);
//        actionList.add(card);
//
//        card = new HandCardInfo();
//        card.setSkillId("99990207");
//        card.setSkillName("新春型四季");
//        card.setBoostPriority(1);
//        card.setPlayedOrder(0);
//        card.setSkill(new ArthurSkill());
//        card.getSkill().setArthurIndex(1);
//        getPriorityTest(skillMap, card);
//        actionList.add(card);
//        card = new HandCardInfo();
//        card.setSkillId("12500762");
//        card.setSkillName("半兽型克蕾斯尼克");
//        card.setBoostPriority(0);
//        card.setPlayedOrder(1);
//        card.setSkill(new ArthurSkill());
//        card.getSkill().setArthurIndex(1);
//        getPriorityTest(skillMap, card);
//        actionList.add(card);
//
//        card = new HandCardInfo();
//        card.setSkillId("13600482");
//        card.setSkillName("异界型 本场切绘");
//        card.setBoostPriority(0);
//        card.setPlayedOrder(0);
//        card.setSkill(new ArthurSkill());
//        card.getSkill().setArthurIndex(2);
//        getPriorityTest(skillMap, card);
//        actionList.add(card);
//        card = new HandCardInfo();
//        card.setSkillId("13200672");
//        card.setSkillName("逆行型斯卡哈");
//        card.setBoostPriority(0);
//        card.setPlayedOrder(1);
//        card.setSkill(new ArthurSkill());
//        card.getSkill().setArthurIndex(2);
//        getPriorityTest(skillMap, card);
//        actionList.add(card);
//
//        card = new HandCardInfo();
//        card.setSkillId("14400442");
//        card.setSkillName("异界型 初音未来 -KEI-");
//        card.setBoostPriority(0);
//        card.setPlayedOrder(0);
//        card.setSkill(new ArthurSkill());
//        card.getSkill().setArthurIndex(3);
//        getPriorityTest(skillMap, card);
//        actionList.add(card);
//        card = new HandCardInfo();
//        card.setSkillId("99990231");
//        card.setSkillName("新春型安琪");
//        card.setBoostPriority(0);
//        card.setPlayedOrder(1);
//        card.setSkill(new ArthurSkill());
//        card.getSkill().setArthurIndex(3);
//        getPriorityTest(skillMap, card);
//        actionList.add(card);
//        card = new HandCardInfo();
//        card.setSkillId("14302082");
//        card.setSkillName("蹴球型多莫维依");
//        card.setBoostPriority(0);
//        card.setPlayedOrder(2);
//        card.setSkill(new ArthurSkill());
//        card.getSkill().setArthurIndex(3);
//        getPriorityTest(skillMap, card);
//        actionList.add(card);
//        card = new HandCardInfo();
//        card.setSkillId("14301662");
//        card.setSkillName("异界型 镜音铃—连");
//        card.setBoostPriority(0);
//        card.setPlayedOrder(3);
//        card.setSkill(new ArthurSkill());
//        card.getSkill().setArthurIndex(3);
//        getPriorityTest(skillMap, card);
//        actionList.add(card);
//
//        // Shuffle the 'cards'.
//        long n = actionList.size();
//        HandCardInfo temp;
//        for (int i = 0; i < n; i++) {
//            Integer index = ((Long) Math.round(Math.random() * (n - i) - 0.5 + i)).intValue();
//            if (index != i) {
//                temp = actionList.get(i);
//                actionList.set(i, actionList.get(index));
//                actionList.set(index, temp);
//            }
//        }
//        // Re-order them.
//        //actionList.sort(Constants.HAND_CARD_CMP);
//        //sortCardOrderWithSamePriority(actionList);
//
//        for (HandCardInfo myCard : actionList) {
//            System.out.println(myCard.getSkillId() + " | " + myCard.getSkillName() + " | " + myCard.getCardSkillPriority());
//        }
//    }
    private static void getPriorityTest(HashMap<String, List<String[]>> skillMap, HandCardInfo card) throws NumberFormatException {
        //System.out.println(card.getSkillId());
        if (skillMap.get(card.getSkillId()).get(card.getBoostPriority())[14].matches("[\\d+]")) {
            card.setCardSkillPriority(Integer.parseInt(skillMap.get(card.getSkillId()).get(card.getBoostPriority())[14]));
        } else {
            card.setCardSkillPriority(Integer.parseInt(skillMap.get(card.getSkillId()).get(0)[14]));
        }
    }

    private void recordTurnInfo() {
        try {
            TurnInfoRecord record = new TurnInfoRecord();
            record.setTurn(turn);
            List<ArthurInfo> aList = new ArrayList<>();
            for (ArthurInfo arthur : arthurList) {
                aList.add(arthur.clone());
            }
            record.setArthurInfo(aList);
            List<EnemyInfo> eList = new ArrayList<>();
            for (EnemyInfo enemy : enemyList) {
                eList.add(enemy.clone());
            }
            record.setEnemyInfo(eList);
            HashMap<String, Integer> flagMap = new HashMap<>();
            for (String key : enemyTriggerAiFlag.keySet()) {
                flagMap.put(key, enemyTriggerAiFlag.get(key));
            }
            record.setEnemyTriggerAiFlag(flagMap);
            turnInfoRecord.add(record);
        } catch (CloneNotSupportedException ex) {
            log.error(ex);
        }
    }

    public void revertTurnInfo() {
        try {
            if (turnInfoRecord.size() < 2) {
                JOptionPane.showMessageDialog(this, "已经是第一回合了。", "注意", JOptionPane.WARNING_MESSAGE);
                return;
            }
            turnInfoRecord.remove(turnInfoRecord.size() - 1);
            TurnInfoRecord record = turnInfoRecord.get(turnInfoRecord.size() - 1);
            this.turn = record.getTurn();
            List<ArthurInfo> aList = new ArrayList<>();
            for (ArthurInfo arthur : record.getArthurInfo()) {
                aList.add(arthur.clone());
            }
            this.arthurList = aList;
            List<EnemyInfo> eList = new ArrayList<>();
            for (EnemyInfo enemy : record.getEnemyInfo()) {
                eList.add(enemy.clone());
            }
            this.enemyList = eList;
            HashMap<String, Integer> flagMap = new HashMap<>();
            for (String key : record.getEnemyTriggerAiFlag().keySet()) {
                flagMap.put(key, record.getEnemyTriggerAiFlag().get(key));
            }
            this.enemyTriggerAiFlag = flagMap;
            haltGame(false);
            computeChains();
            computeIsBoost();
            computeSkillValues();
            refreshArthurUI();
            refreshEnemyUI();
            lblTitle.setText("第" + turn + "回合");
            txtBattleInfo.append("◎◎◎◎◎◎◎◎◎◎◎◎◎◎◎回到第" + turn + "回合◎◎◎◎◎◎◎◎◎◎◎◎◎◎◎\n\n");
            for (int i = 0; i < 4; i++) {
                if (arStatusTButton.get(i).isSelected()) {
                    refreshCardUI(i);
                }
            }
        } catch (CloneNotSupportedException ex) {
            log.error(ex);
        }
    }

    public void tryCardSelection(MouseEvent event, Integer cardPanelIndex) {
        if (!((MainFrame) UIUtil.getMainFrame()).cardSelectionEnabled()
                || !showCards || !btnSwitch.isEnabled()) {
            return;
        }
        ArthurInfo arthur = null;
        for (int i = 0; i < arStatusTButton.size(); i++) {
            if (arStatusTButton.get(i).isSelected()) {
                arthur = arthurList.get(i);
            }
        }
        if (arthur == null || arthur.getHandCards() == null || arthur.getHandCards()[cardPanelIndex] == null) {
            return;
        }
        HandCardInfo cardToReplace = arthur.getHandCards()[cardPanelIndex];
        if (cardToReplace.isPlayed() || cardToReplace.getIsSealed() > 0) {
            JOptionPane.showMessageDialog(this, "使用中或被封印的卡牌无法替换。", "注意", JOptionPane.WARNING_MESSAGE);
            return;
        }
        if (!cardToReplace.getDealedTurn().equals(turn)) {
            JOptionPane.showMessageDialog(this, "非本轮抽到的卡牌无法替换。", "注意", JOptionPane.WARNING_MESSAGE);
            return;
        }
        if (cardToReplace.isFirstRoundCard()) {
            popupMenu.initPopupMenu(arthur, cardToReplace, arthur.getFirstRoundDeck(), arthur.getDeck());
        } else {
            popupMenu.initPopupMenu(arthur, cardToReplace, arthur.getDeckCards(), arthur.getDeck());
        }
        popupMenu.show(event.getComponent(), event.getX(), event.getY());
    }

    public void doneCardSelection(ArthurInfo arthur, HandCardInfo cardToReplace, String selectedCardId) {
        String cardToReplaceId = cardToReplace.getSkillId();
        if (cardToReplace.isFirstRoundCard()) {
            int index = arthur.getFirstRoundDeck().indexOf(selectedCardId);
            arthur.getFirstRoundDeck().add(index, cardToReplaceId);
            arthur.getFirstRoundDeck().remove(selectedCardId);
        }
        arthur.getDeckCards().remove(selectedCardId);
        arthur.getDeckCards().add(cardToReplaceId);

        cardToReplace.setSkillId(selectedCardId);
        cardToReplace.setSkill(arthur.getDeck().get(selectedCardId));

        computeChains();
        computeIsBoost();
        computeSkillValues();
        refreshCardUI(arthur.getPartIndex());
    }

}
